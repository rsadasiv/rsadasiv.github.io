<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BiberAnnotator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OOP Core NLP</a> &gt; <a href="index.source.html" class="el_package">io.outofprintmagazine.nlp.pipeline.annotators</a> &gt; <span class="el_source">BiberAnnotator.java</span></div><h1>BiberAnnotator.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (C) 2020 Ram Sadasiv
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 ******************************************************************************/
package io.outofprintmagazine.nlp.pipeline.annotators;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import edu.stanford.nlp.ling.CoreAnnotation;
import edu.stanford.nlp.ling.CoreAnnotations;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.ling.tokensregex.TokenSequenceMatcher;
import edu.stanford.nlp.ling.tokensregex.TokenSequencePattern;
import edu.stanford.nlp.pipeline.Annotation;
import edu.stanford.nlp.pipeline.Annotator;
import edu.stanford.nlp.pipeline.CoreDocument;
import edu.stanford.nlp.pipeline.CoreSentence;
import edu.stanford.nlp.util.ArraySet;
import edu.stanford.nlp.util.CoreMap;
import io.outofprintmagazine.nlp.pipeline.scorers.MapSum;
import io.outofprintmagazine.nlp.pipeline.scorers.IScorer;
import io.outofprintmagazine.nlp.pipeline.serializers.MapSerializer;
import io.outofprintmagazine.nlp.pipeline.serializers.ISerializer;
import io.outofprintmagazine.nlp.utils.ResourceUtils;

public class BiberAnnotator extends AbstractPosAnnotator implements Annotator, IOOPAnnotator{
	
	@SuppressWarnings(&quot;unused&quot;)
<span class="fc" id="L51">	private static final Logger logger = LogManager.getLogger(BiberAnnotator.class);</span>
	
	@SuppressWarnings(&quot;unused&quot;)
	private Logger getLogger() {
<span class="nc" id="L55">		return logger;</span>
	}
	
	public BiberAnnotator() {
<span class="fc" id="L59">		super();</span>
<span class="fc" id="L60">		this.setScorer((IScorer)new MapSum(this.getAnnotationClass()));</span>
<span class="fc" id="L61">		this.setSerializer((ISerializer)new MapSerializer(this.getAnnotationClass()));		</span>
<span class="fc" id="L62">	}</span>

	@Override
	public Class getAnnotationClass() {
<span class="fc" id="L66">		return io.outofprintmagazine.nlp.pipeline.OOPAnnotations.OOPBiberAnnotation.class;</span>
	}

	
	@Override
	public String getDescription() {
<span class="fc" id="L72">		return &quot;Biber: Variation across speech and writing. https://drive.google.com/file/d/11BAw-Dl5FDLTJFXqixc2uIgQQtU0g0no/view.&quot;;</span>
	}


	@Override
	public Set&lt;Class&lt;? extends CoreAnnotation&gt;&gt; requires() {
<span class="nc" id="L78">		return Collections.unmodifiableSet(</span>
			new ArraySet&lt;&gt;(
<span class="nc" id="L80">				Arrays.asList(</span>
					CoreAnnotations.TextAnnotation.class, 
					CoreAnnotations.TokensAnnotation.class,
					CoreAnnotations.SentencesAnnotation.class
					)
				)
			);
	}

	@Override
	public void annotate(Annotation annotation) {
<span class="fc" id="L91">		annotate_VBD(annotation);</span>
<span class="fc" id="L92">		annotate_PEAS(annotation);</span>
<span class="fc" id="L93">		annotate_VPRT(annotation);</span>
<span class="fc" id="L94">		annotate_PLACE(annotation);</span>
<span class="fc" id="L95">		annotate_TIME(annotation);</span>
<span class="fc" id="L96">		annotate_FPP1(annotation);</span>
<span class="fc" id="L97">		annotate_SPP2(annotation);</span>
<span class="fc" id="L98">		annotate_TPP3(annotation);</span>
<span class="fc" id="L99">		annotate_PIT(annotation);</span>
<span class="fc" id="L100">		annotate_DEMP(annotation);</span>
<span class="fc" id="L101">		annotate_INPR(annotation);</span>
<span class="fc" id="L102">		annotate_PROD(annotation);</span>
<span class="fc" id="L103">		annotate_WHQU(annotation);</span>
<span class="fc" id="L104">		annotate_NOMZ(annotation);</span>
<span class="fc" id="L105">		annotate_GER(annotation);</span>
<span class="fc" id="L106">		annotate_NN(annotation);</span>
<span class="fc" id="L107">		annotate_PASS(annotation);</span>
<span class="fc" id="L108">		annotate_BYPA(annotation);</span>
<span class="fc" id="L109">		annotate_BEMA(annotation);</span>
<span class="fc" id="L110">		annotate_EX(annotation);</span>
<span class="fc" id="L111">		annotate_THVC(annotation);</span>
<span class="fc" id="L112">		annotate_THAC(annotation);</span>
<span class="fc" id="L113">		annotate_WHCL(annotation);</span>
<span class="fc" id="L114">		annotate_TO(annotation);</span>
<span class="fc" id="L115">		annotate_PRESP(annotation);</span>
<span class="fc" id="L116">		annotate_PASTP(annotation);</span>
<span class="fc" id="L117">		annotate_WZPAST(annotation);</span>
<span class="fc" id="L118">		annotate_WZPRES(annotation);</span>
<span class="fc" id="L119">		annotate_TSUB(annotation);</span>
<span class="fc" id="L120">		annotate_TOBJ(annotation);</span>
<span class="fc" id="L121">		annotate_WHSUB(annotation);</span>
<span class="fc" id="L122">		annotate_WHOBJ(annotation);</span>
<span class="fc" id="L123">		annotate_PIRE(annotation);</span>
<span class="fc" id="L124">		annotate_SERE(annotation);</span>
<span class="fc" id="L125">		annotate_CAUS(annotation);</span>
<span class="fc" id="L126">		annotate_CONC(annotation);</span>
<span class="fc" id="L127">		annotate_COND(annotation);</span>
<span class="fc" id="L128">		annotate_OSUB(annotation);</span>
<span class="fc" id="L129">		annotate_PIN(annotation);</span>
<span class="fc" id="L130">		annotate_JJ(annotation);</span>
<span class="fc" id="L131">		annotate_PRED(annotation);</span>
<span class="fc" id="L132">		annotate_RB(annotation);</span>
<span class="fc" id="L133">		annotate_CONJ(annotation);</span>
<span class="fc" id="L134">		annotate_DWNT(annotation);</span>
<span class="fc" id="L135">		annotate_HDG(annotation);</span>
<span class="fc" id="L136">		annotate_AMP(annotation);</span>
<span class="fc" id="L137">		annotate_EMPH(annotation);</span>
<span class="fc" id="L138">		annotate_DPAR(annotation);</span>
<span class="fc" id="L139">		annotate_DEMO(annotation);</span>
<span class="fc" id="L140">		annotate_POMD(annotation);</span>
<span class="fc" id="L141">		annotate_NEMD(annotation);</span>
<span class="fc" id="L142">		annotate_PRMD(annotation);</span>
<span class="fc" id="L143">		annotate_PUBV(annotation);</span>
<span class="fc" id="L144">		annotate_PRIV(annotation);</span>
<span class="fc" id="L145">		annotate_SUAV(annotation);</span>
<span class="fc" id="L146">		annotate_SEMP(annotation);</span>
<span class="fc" id="L147">		annotate_CONT(annotation);</span>
<span class="fc" id="L148">		annotate_THATD(annotation);</span>
<span class="fc" id="L149">		annotate_STPR(annotation);</span>
<span class="fc" id="L150">		annotate_SPIN(annotation);</span>
<span class="fc" id="L151">		annotate_SPAU(annotation);</span>
<span class="fc" id="L152">		annotate_PHC(annotation);</span>
<span class="fc" id="L153">		annotate_ANDC(annotation);</span>
<span class="fc" id="L154">		annotate_SYNE(annotation);</span>
<span class="fc" id="L155">		annotate_XX0(annotation);</span>
<span class="fc" id="L156">	}</span>
	
	@Override
	public void score(CoreDocument document) {
<span class="fc" id="L160">		super.score(document);</span>
<span class="fc" id="L161">		annotate_AWL(document.annotation());</span>
<span class="fc" id="L162">		annotate_TTR(document.annotation());</span>
<span class="fc" id="L163">	}</span>
	
	private Map&lt;String,BigDecimal&gt; getBiberAnnotation(CoreMap coreMap) {
<span class="fc" id="L166">		Map&lt;String,BigDecimal&gt; retval = null;</span>
		try {
<span class="fc" id="L168">			retval = (Map&lt;String,BigDecimal&gt;) coreMap.get(getAnnotationClass());</span>
		}
<span class="nc" id="L170">		catch (Throwable t) {</span>
<span class="nc" id="L171">			logger.error(t);</span>
<span class="fc" id="L172">		}</span>
<span class="fc bfc" id="L173" title="All 2 branches covered.">		if (retval == null) {</span>
<span class="fc" id="L174">			retval = new HashMap&lt;String, BigDecimal&gt;();</span>
		}
<span class="fc" id="L176">		return retval;	</span>
	}
	
	public void annotate_VBD(Annotation annotation) {
<span class="fc" id="L180">		List&lt;String&gt; posTags = Arrays.asList(&quot;VBD&quot;);</span>
<span class="fc" id="L181">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L182" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">			for (CoreLabel token : sentence.tokens()) {</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">				if (posTags.contains(token.tag())) {</span>
<span class="fc" id="L185">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L186">					addToScoreMap(scoreMap, &quot;VBD&quot;, new BigDecimal(1));</span>
<span class="fc" id="L187">					token.set(getAnnotationClass(), scoreMap);</span>
				}
<span class="fc" id="L189">			}</span>
<span class="fc" id="L190">		}</span>
<span class="fc" id="L191">	}</span>
	

	public void annotate_PEAS(Annotation annotation) {
/*
This is calculated by counting how many times a form of HAVE is followed by: a VBD or
VBN tag (a past or participle form of any verb). These are also counted when an adverb (RB)
or negation (XX0) occurs between the two. The interrogative version is counted too. This is
achieved by counting how many times a form of HAVE is followed by a nominal form
(noun, NN, proper noun, NP or personal pronoun, PRP) and then followed by a VBD or VBN
tag. As for the affirmative version, the latter algorithm also accounts for intervening adverbs
or negations. 
 */
		
<span class="fc" id="L205">		List&lt;String&gt; posTags = Arrays.asList(&quot;VBD&quot;, &quot;VBN&quot;);</span>
<span class="fc" id="L206">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">			for (int i=0;i&lt;sentence.tokens().size();i++) {</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">				if (i&lt;sentence.tokens().size()-1) {</span>
<span class="fc bfc" id="L210" title="All 4 branches covered.">					if (sentence.tokens().get(i).lemma().equals(&quot;have&quot;) &amp;&amp; posTags.contains(sentence.tokens().get(i+1).tag())) {</span>
<span class="fc" id="L211">						Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(sentence.tokens().get(i));</span>
<span class="fc" id="L212">						addToScoreMap(scoreMap, &quot;PEAS&quot;, new BigDecimal(1));</span>
<span class="fc" id="L213">						sentence.tokens().get(i).set(getAnnotationClass(), scoreMap);</span>
					}					
				}
<span class="fc bfc" id="L216" title="All 2 branches covered.">				if (i&lt;sentence.tokens().size()-2) {</span>
<span class="pc bpc" id="L217" title="1 of 8 branches missed.">					if (sentence.tokens().get(i).lemma().equals(&quot;have&quot;) &amp;&amp; (sentence.tokens().get(i+1).tag().equals(&quot;RB&quot;) || sentence.tokens().get(i+1).lemma().equals(&quot;not&quot;)) &amp;&amp; posTags.contains(sentence.tokens().get(i+2).tag())) {</span>
<span class="fc" id="L218">						Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(sentence.tokens().get(i));</span>
<span class="fc" id="L219">						addToScoreMap(scoreMap, &quot;PEAS&quot;, new BigDecimal(1));</span>
<span class="fc" id="L220">						sentence.tokens().get(i).set(getAnnotationClass(), scoreMap);</span>
					}					
				}
			}
<span class="fc" id="L224">		}</span>
<span class="fc" id="L225">	}</span>
	
	public void annotate_VPRT(Annotation annotation) {
<span class="fc" id="L228">		List&lt;String&gt; posTags = Arrays.asList(&quot;VBP&quot;, &quot;VBZ&quot;);</span>
<span class="fc" id="L229">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L230" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc bfc" id="L231" title="All 2 branches covered.">			for (CoreLabel token : sentence.tokens()) {</span>
<span class="fc bfc" id="L232" title="All 2 branches covered.">				if (posTags.contains(token.tag())) {</span>
<span class="fc" id="L233">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L234">					addToScoreMap(scoreMap, &quot;VPRT&quot;, new BigDecimal(1));</span>
<span class="fc" id="L235">					token.set(getAnnotationClass(), scoreMap);</span>
				}
<span class="fc" id="L237">			}</span>
<span class="fc" id="L238">		}</span>
<span class="fc" id="L239">	}</span>
	
	public void annotate_PLACE(Annotation annotation) {
		try {
<span class="fc" id="L243">			List&lt;String&gt; posTags = Arrays.asList(&quot;NNP&quot;);</span>
<span class="fc" id="L244">			List&lt;String&gt; tags = ResourceUtils.getInstance(getParameterStore()).getList(&quot;io/outofprintmagazine/nlp/models/Biber/PLACE.txt&quot;);</span>
<span class="fc" id="L245">			CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">			for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">				for (CoreLabel token : sentence.tokens()) {</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">					if (!posTags.contains(token.tag())) {</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">						if (tags.contains(token.lemma())) {</span>
<span class="fc" id="L250">							Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L251">							addToScoreMap(scoreMap, &quot;PLACE&quot;, new BigDecimal(1));</span>
<span class="fc" id="L252">							token.set(getAnnotationClass(), scoreMap);</span>
						}
					}
<span class="fc" id="L255">				}</span>
<span class="fc" id="L256">			}</span>
		}
<span class="nc" id="L258">		catch (Exception e) {</span>
<span class="nc" id="L259">			logger.error(e);</span>
<span class="fc" id="L260">		}</span>
<span class="fc" id="L261">	}</span>
	
	
	public void annotate_TIME(Annotation annotation) {
		try {
<span class="fc" id="L266">			List&lt;String&gt; tags = ResourceUtils.getInstance(getParameterStore()).getList(&quot;io/outofprintmagazine/nlp/models/Biber/TIME.txt&quot;);</span>
<span class="fc" id="L267">			CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">			for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc" id="L269">				boolean soonAs = false;</span>
<span class="fc bfc" id="L270" title="All 2 branches covered.">				for (CoreLabel token : sentence.tokens()) {</span>
<span class="pc bpc" id="L271" title="3 of 6 branches missed.">					if (tags.contains(token.lemma()) || (soonAs &amp;&amp; token.lemma().equals(&quot;as&quot;))) {</span>
<span class="fc" id="L272">						Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L273">						addToScoreMap(scoreMap, &quot;TIME&quot;, new BigDecimal(1));</span>
<span class="fc" id="L274">						token.set(getAnnotationClass(), scoreMap);</span>
					}
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">					if (token.lemma().equals(&quot;soon&quot;)) {</span>
<span class="nc" id="L277">						soonAs = true;</span>
					}
					else {
<span class="fc" id="L280">						soonAs = false;</span>
					}
<span class="fc" id="L282">				}</span>
<span class="fc" id="L283">			}</span>
		}
<span class="nc" id="L285">		catch (Exception e) {</span>
<span class="nc" id="L286">			logger.error(e);</span>
<span class="fc" id="L287">		}</span>
<span class="fc" id="L288">	}</span>
	
	public void annotate_FPP1(Annotation annotation) {
<span class="fc" id="L291">		List&lt;String&gt; tags = Arrays.asList(&quot;i&quot;, &quot;me&quot;, &quot;us&quot;, &quot;my&quot;, &quot;we&quot;, &quot;our&quot;, &quot;myself&quot;, &quot;ourselves&quot;);</span>
<span class="fc" id="L292">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L293" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc bfc" id="L294" title="All 2 branches covered.">			for (CoreLabel token : sentence.tokens()) {</span>
<span class="fc bfc" id="L295" title="All 2 branches covered.">				if (tags.contains(token.lemma().toLowerCase())) {</span>
<span class="fc" id="L296">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L297">					addToScoreMap(scoreMap, &quot;FPP1&quot;, new BigDecimal(1));</span>
<span class="fc" id="L298">					token.set(getAnnotationClass(), scoreMap);</span>
				}
<span class="fc" id="L300">			}</span>
<span class="fc" id="L301">		}</span>
<span class="fc" id="L302">	}</span>
	
	public void annotate_SPP2(Annotation annotation) {
<span class="fc" id="L305">		List&lt;String&gt; tags = Arrays.asList(&quot;you&quot;, &quot;your&quot;, &quot;yourself&quot;, &quot;yourselves&quot;, &quot;thy&quot;, &quot;thee&quot;, &quot;thyself&quot;, &quot;thou&quot;);</span>
<span class="fc" id="L306">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L307" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc bfc" id="L308" title="All 2 branches covered.">			for (CoreLabel token : sentence.tokens()) {</span>
<span class="fc bfc" id="L309" title="All 2 branches covered.">				if (tags.contains(token.lemma())) {</span>
<span class="fc" id="L310">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L311">					addToScoreMap(scoreMap, &quot;SPP2&quot;, new BigDecimal(1));</span>
<span class="fc" id="L312">					token.set(getAnnotationClass(), scoreMap);</span>
				}
<span class="fc" id="L314">			}</span>
<span class="fc" id="L315">		}</span>
<span class="fc" id="L316">	}</span>
	
	public void annotate_TPP3(Annotation annotation) {
<span class="fc" id="L319">		List&lt;String&gt; tags = Arrays.asList(&quot;she&quot;, &quot;he&quot;, &quot;they&quot;, &quot;her&quot;, &quot;him&quot;, &quot;them&quot;, &quot;his&quot;, &quot;their&quot;, &quot;himself&quot;, &quot;herself&quot;, &quot;themselves&quot;);</span>
<span class="fc" id="L320">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L321" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc bfc" id="L322" title="All 2 branches covered.">			for (CoreLabel token : sentence.tokens()) {</span>
<span class="fc bfc" id="L323" title="All 2 branches covered.">				if (tags.contains(token.lemma())) {</span>
<span class="fc" id="L324">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L325">					addToScoreMap(scoreMap, &quot;TPP3&quot;, new BigDecimal(1));</span>
<span class="fc" id="L326">					token.set(getAnnotationClass(), scoreMap);</span>
				}
<span class="fc" id="L328">			}</span>
<span class="fc" id="L329">		}</span>
<span class="fc" id="L330">	}</span>
	
	public void annotate_PIT(Annotation annotation) {
<span class="fc" id="L333">		List&lt;String&gt; tags = Arrays.asList(&quot;it&quot;, &quot;its&quot;, &quot;itself&quot;);</span>
<span class="fc" id="L334">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L335" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">			for (CoreLabel token : sentence.tokens()) {</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">				if (tags.contains(token.lemma())) {</span>
<span class="fc" id="L338">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L339">					addToScoreMap(scoreMap, &quot;PIT&quot;, new BigDecimal(1));</span>
<span class="fc" id="L340">					token.set(getAnnotationClass(), scoreMap);</span>
				}
<span class="fc" id="L342">			}</span>
<span class="fc" id="L343">		}</span>
<span class="fc" id="L344">	}</span>
	
	//TODO
	public void annotate_DEMP(Annotation annotation) {
/*
The program tags as demonstrative pronouns the words those, this, these when they are
followed by a verb (any tag starting with V) or auxiliary verb (modal verbs in the form of 
MD tags or forms of DO or forms of HAVE or forms of BE) or a punctuation mark or a WH
pronoun or the word and. The word that is tagged as a demonstrative pronoun when it
follows the said pattern or when it is followed by ‘s or is and, at the same time, it has not
been already tagged as a TOBJ, TSUB, THAC or THVC.  
 */
<span class="fc" id="L356">	}</span>
	
	public void annotate_INPR(Annotation annotation) {
<span class="fc" id="L359">		List&lt;String&gt; tags = Arrays.asList(&quot;anybody&quot;, &quot;anyone&quot;, &quot;anything&quot;, &quot;everybody&quot;,	&quot;everyone&quot;,	&quot;everything&quot;, &quot;nobody&quot;,	&quot;none&quot;,	&quot;nothing&quot;, &quot;nowhere&quot;, &quot;somebody&quot;, &quot;someone&quot;, &quot;something&quot;);</span>
<span class="fc" id="L360">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc bfc" id="L362" title="All 2 branches covered.">			for (CoreLabel token : sentence.tokens()) {</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">				if (tags.contains(token.lemma())) {</span>
<span class="fc" id="L364">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L365">					addToScoreMap(scoreMap, &quot;INPR&quot;, new BigDecimal(1));</span>
<span class="fc" id="L366">					token.set(getAnnotationClass(), scoreMap);</span>
				}
<span class="fc" id="L368">			}</span>
<span class="fc" id="L369">		}</span>
<span class="fc" id="L370">	}</span>
	

	public void annotate_PROD(Annotation annotation) {
/*
Any form of DO that is used as main verb and, therefore, excluding DO when used as
auxiliary verb. The tagger tags as PROD any DO that is NOT in neither of the following
patterns: (a) DO followed by a verb (any tag starting with V) or followed by adverbs (RB),
negations and then a verb (V); (b) DO preceded by a punctuation mark or a WH pronoun (the
list of WH pronouns is in Biber (1988)).  
 */
<span class="fc" id="L381">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc bfc" id="L383" title="All 2 branches covered.">			for (int i=0;i&lt;sentence.tokens().size();i++) {</span>
<span class="fc bfc" id="L384" title="All 2 branches covered.">				if (i&lt;sentence.tokens().size()-1) {</span>
<span class="pc bpc" id="L385" title="1 of 6 branches missed.">					if (sentence.tokens().get(i).lemma().equals(&quot;do&quot;) &amp;&amp; !sentence.tokens().get(i+1).tag().startsWith(&quot;V&quot;) &amp;&amp; (!sentence.tokens().get(i+1).tag().equals(&quot;RB&quot;))) {</span>
<span class="pc bpc" id="L386" title="1 of 6 branches missed.">						if (i&gt;0 &amp;&amp; !sentence.tokens().get(i-1).tag().equals(&quot;WP&quot;) &amp;&amp; !isPunctuationMark(sentence.tokens().get(i-1))) {</span>
<span class="fc" id="L387">							Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(sentence.tokens().get(i));</span>
<span class="fc" id="L388">							addToScoreMap(scoreMap, &quot;PROD&quot;, new BigDecimal(1));</span>
<span class="fc" id="L389">							sentence.tokens().get(i).set(getAnnotationClass(), scoreMap);</span>
						}
					}					
				}
			}
<span class="fc" id="L394">		}</span>
<span class="fc" id="L395">	}</span>
	

	public void annotate_WHQU(Annotation annotation) {
/*
Any punctuation followed by a WH word (what, where, when, how, whether, why, whoever,
whomever, whichever, wherever, whenever, whatever, however) and followed by any
auxiliary verb (modal verbs in the form of MD tags or forms of DO or forms of HAVE or
forms of BE). This algorithm was slightly changed by allowing an intervening word between
the punctuation mark and the WH word. This allows WH-questions containing discourse
markers such as ‘so’ or ‘anyways’ to be recognised. Furthermore, Biber’s algorithm was
improved by excluding WH words such as however or whatever that do not introduce WHquestions.  
 */

<span class="fc" id="L409">		List&lt;String&gt; posTags = Arrays.asList(&quot;WP&quot;, &quot;WP$&quot;, &quot;WDT&quot;);</span>
<span class="fc" id="L410">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L411" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc" id="L412">			CoreLabel whToken = null;</span>
			
<span class="fc bfc" id="L414" title="All 2 branches covered.">			for (CoreLabel token : sentence.tokens()) {</span>
<span class="fc bfc" id="L415" title="All 2 branches covered.">				if (posTags.contains(token.tag())) {</span>
<span class="fc" id="L416">					whToken = token;</span>
				}
<span class="fc bfc" id="L418" title="All 8 branches covered.">				else if (whToken != null &amp;&amp; (token.tag().equals(&quot;MD&quot;) || token.lemma().equals(&quot;do&quot;) || token.lemma().equals(&quot;have&quot;))) {</span>
<span class="fc" id="L419">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L420">					addToScoreMap(scoreMap, &quot;WHQU&quot;, new BigDecimal(1));</span>
<span class="fc" id="L421">					whToken.set(getAnnotationClass(), scoreMap);</span>
<span class="fc" id="L422">				}</span>
				else {
<span class="fc" id="L424">					whToken = null;</span>
				}
<span class="fc" id="L426">			}</span>
<span class="fc" id="L427">		}</span>

<span class="fc" id="L429">	}</span>
	
	
	public void annotate_NOMZ(Annotation annotation) {
<span class="fc" id="L433">		List&lt;String&gt; tags = Arrays.asList(&quot;tion&quot;, &quot;ment&quot;, &quot;ness&quot;, &quot;ity&quot;, &quot;tions&quot;, &quot;ments&quot;, &quot;nesses&quot;, &quot;ities&quot;);</span>
<span class="fc" id="L434">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L435" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc bfc" id="L436" title="All 2 branches covered.">			for (CoreLabel token : sentence.tokens()) {</span>
<span class="fc bfc" id="L437" title="All 2 branches covered.">				for (String ending : tags) {</span>
<span class="fc bfc" id="L438" title="All 4 branches covered.">					if (token.lemma().endsWith(ending) &amp;&amp; (token.lemma().length() &gt; (ending.length()+2))) {</span>
<span class="fc" id="L439">						Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L440">						addToScoreMap(scoreMap, &quot;NOMZ&quot;, new BigDecimal(1));</span>
<span class="fc" id="L441">						token.set(getAnnotationClass(), scoreMap);</span>
					}
<span class="fc" id="L443">				}</span>
<span class="fc" id="L444">			}</span>
<span class="fc" id="L445">		}</span>
<span class="fc" id="L446">	}</span>
	

	public void annotate_GER(Annotation annotation) {
		//List&lt;String&gt; tags = Arrays.asList(&quot;ing&quot;, &quot;ings&quot;);
<span class="fc" id="L451">		List&lt;String&gt; posTags = Arrays.asList(&quot;VBG&quot;);</span>
<span class="fc" id="L452">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L453" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc bfc" id="L454" title="All 2 branches covered.">			for (CoreLabel token : sentence.tokens()) {</span>
				//for (String ending : tags) {
					//if (token.lemma().endsWith(ending) &amp;&amp; (token.lemma().length() &gt; 10)) {
<span class="fc bfc" id="L457" title="All 2 branches covered.">				if (posTags.contains(token.tag())) {</span>
<span class="fc" id="L458">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L459">					addToScoreMap(scoreMap, &quot;GER&quot;, new BigDecimal(1));</span>
<span class="fc" id="L460">					token.set(getAnnotationClass(), scoreMap);</span>
				}
<span class="fc" id="L462">			}</span>
<span class="fc" id="L463">		}</span>
<span class="fc" id="L464">	}</span>
	
	//DONE - Must run after GER and NOMZ
	public void annotate_NN(Annotation annotation) {
<span class="fc" id="L468">		List&lt;String&gt; posTags = Arrays.asList(&quot;NN&quot;, &quot;NNS&quot;, &quot;NNP&quot;, &quot;NNPS&quot;);</span>
<span class="fc" id="L469">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L470" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc bfc" id="L471" title="All 2 branches covered.">			for (CoreLabel token : sentence.tokens()) {</span>
<span class="fc bfc" id="L472" title="All 2 branches covered.">				if (posTags.contains(token.tag())) {</span>
<span class="fc" id="L473">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="pc bpc" id="L474" title="1 of 4 branches missed.">					if (scoreMap.get(&quot;GER&quot;) == null &amp;&amp; scoreMap.get(&quot;NOMZ&quot;) == null) {</span>
<span class="fc" id="L475">						addToScoreMap(scoreMap, &quot;NN&quot;, new BigDecimal(1));</span>
<span class="fc" id="L476">						token.set(getAnnotationClass(), scoreMap);</span>
					}
				}
<span class="fc" id="L479">			}</span>
<span class="fc" id="L480">		}</span>
<span class="fc" id="L481">	}</span>
	

	public void annotate_PASS(Annotation annotation) {
/*
This tag is assigned when one of the two following patterns is found: (a) any form of BE
followed by a participle (VBN or VBD) plus one or two optional intervening adverbs (RB) or
negations; (b) any form of BE followed by a nominal form (a noun, NN, NNP or personal
pronoun, PRP) and a participle (VBN or VBD). This algorithm was slightly changed from
Biber’s version in the present tagger. It was felt necessary to implement the possibility of an
intervening negation in the pattern (b). This tag is therefore assigned also in the cases in
which a negation precedes the nominal form of pattern (b).  
 */
<span class="fc" id="L494">		List&lt;String&gt; posTags = Arrays.asList(&quot;VBN&quot;, &quot;VBD&quot;);</span>
<span class="fc" id="L495">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L496" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc" id="L497">			boolean wasBe = false;</span>
<span class="fc bfc" id="L498" title="All 2 branches covered.">			for (CoreLabel token : sentence.tokens()) {</span>
<span class="fc bfc" id="L499" title="All 4 branches covered.">				if (posTags.contains(token.tag()) &amp;&amp; wasBe) {</span>
<span class="fc" id="L500">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L501">					addToScoreMap(scoreMap, &quot;PASS&quot;, new BigDecimal(1));</span>
<span class="fc" id="L502">					token.set(getAnnotationClass(), scoreMap);</span>
<span class="fc" id="L503">					break;</span>
				}
<span class="fc bfc" id="L505" title="All 2 branches covered.">				if (token.lemma().equals(&quot;be&quot;)) {</span>
<span class="fc" id="L506">					wasBe = true;</span>
				}
				else {
<span class="fc" id="L509">					wasBe = false;</span>
				}
<span class="fc" id="L511">			}</span>
<span class="fc" id="L512">		}</span>
<span class="fc" id="L513">	}</span>
	
	//DONE - Must run after PASS
	public void annotate_BYPA(Annotation annotation) {
<span class="fc" id="L517">		List&lt;String&gt; tags = Arrays.asList(&quot;by&quot;);</span>
<span class="fc" id="L518">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L519" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc" id="L520">			boolean wasPASS = false;</span>
<span class="fc bfc" id="L521" title="All 2 branches covered.">			for (CoreLabel token : sentence.tokens()) {</span>
<span class="fc bfc" id="L522" title="All 4 branches covered.">				if (tags.contains(token.lemma()) &amp;&amp; wasPASS) {</span>
<span class="fc" id="L523">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L524">					addToScoreMap(scoreMap, &quot;BYPA&quot;, new BigDecimal(1));</span>
<span class="fc" id="L525">					token.set(getAnnotationClass(), scoreMap);</span>
				}
<span class="fc bfc" id="L527" title="All 2 branches covered.">				if (getBiberAnnotation(token).get(&quot;PASS&quot;) != null) {</span>
<span class="fc" id="L528">					wasPASS = true;</span>
				}
				else {
<span class="fc" id="L531">					wasPASS = false;</span>
				}
<span class="fc" id="L533">			}</span>
<span class="fc" id="L534">		}</span>
<span class="fc" id="L535">	}</span>
	

	public void annotate_BEMA(Annotation annotation) {
/*
BE is tagged as being a main verb in the following pattern: BE followed by a determiner
(DT), or a possessive pronoun (PRP$) or a preposition (PIN) or an adjective (JJ). This
algorithm was improved in the present tagger by taking into account that adverbs or negations
can appear between the verb BE and the rest of the pattern. Furthermore, the algorithm was
slightly modified and improved: (a) the problem of a double-coding of any Existential there
followed by a form of BE as a BEMA was solved by imposing the condition that there should
not appear before the pattern; (b) the cardinal numbers (CD) tag and the personal pronoun
(PRP) tag were added to the list of items that can follow the form of BE. 
 */
<span class="fc" id="L549">		List&lt;String&gt; posTags = Arrays.asList(&quot;DT&quot;, &quot;PRP$&quot;, &quot;IN&quot;, &quot;JJ&quot;);</span>
<span class="fc" id="L550">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L551" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc bfc" id="L552" title="All 2 branches covered.">			for (int i=0;i&lt;sentence.tokens().size();i++) {</span>
<span class="fc bfc" id="L553" title="All 2 branches covered.">				if (i&lt;sentence.tokens().size()-1) {</span>
<span class="fc bfc" id="L554" title="All 4 branches covered.">					if (sentence.tokens().get(i).lemma().equals(&quot;be&quot;) &amp;&amp; posTags.contains(sentence.tokens().get(i+1).tag())) {</span>
<span class="fc" id="L555">						Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(sentence.tokens().get(i));</span>
<span class="fc" id="L556">						addToScoreMap(scoreMap, &quot;BEMA&quot;, new BigDecimal(1));</span>
<span class="fc" id="L557">						sentence.tokens().get(i).set(getAnnotationClass(), scoreMap);</span>
					}					
				}
			}
<span class="fc" id="L561">		}</span>
<span class="fc" id="L562">	}</span>
	
	public void annotate_EX(Annotation annotation) {
<span class="fc" id="L565">		List&lt;String&gt; posTags = Arrays.asList(&quot;EX&quot;);</span>
<span class="fc" id="L566">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L567" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc bfc" id="L568" title="All 2 branches covered.">			for (CoreLabel token : sentence.tokens()) {</span>
<span class="fc bfc" id="L569" title="All 2 branches covered.">				if (posTags.contains(token.tag())) {</span>
<span class="fc" id="L570">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L571">					addToScoreMap(scoreMap, &quot;EX&quot;, new BigDecimal(1));</span>
<span class="fc" id="L572">					token.set(getAnnotationClass(), scoreMap);</span>
				}
<span class="fc" id="L574">			}</span>
<span class="fc" id="L575">		}</span>
<span class="fc" id="L576">	}</span>
	

	public void annotate_THVC(Annotation annotation) {
/*
This tag is assigned when the word that is: (1) preceded by and, nor, but, or, also or any
punctuation mark and followed by a determiner (DT, QUAN, CD), a pronoun (PRP), there, a
plural noun (NNS) or a proper noun (NNP); (2) preceded by a public, private or suasive verb
or a form of seem or appear and followed by any word that is NOT a verb (V), auxiliary verb
(MD, form of DO, form of HAVE, form of BE), a punctuation or the word and; (3) preceded
by a public, private or suasive verb or a form of seem or appear and a preposition and up to
four words that are not nouns (N). 
 */
<span class="fc" id="L589">		TokenSequencePattern pattern= TokenSequencePattern.compile(&quot;[{lemma:and} | {lemma:nor} | {lemma:but} | {lemma:or} | {lemma:also}] [lemma:that]&quot;);</span>
<span class="fc" id="L590">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L591" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc" id="L592">			List&lt;CoreLabel&gt; tokens = sentence.tokens();</span>

<span class="fc" id="L594">			TokenSequenceMatcher matcher = pattern.getMatcher(tokens);</span>
<span class="fc bfc" id="L595" title="All 2 branches covered.">			while (matcher.find()) {</span>
<span class="fc" id="L596">				List&lt;CoreMap&gt; matchedTokens = matcher.groupNodes();</span>
<span class="fc" id="L597">				CoreMap token = null;</span>
<span class="fc bfc" id="L598" title="All 2 branches covered.">				for (CoreMap t : matchedTokens) {</span>
<span class="fc" id="L599">					token = t;</span>
<span class="fc" id="L600">				}</span>
<span class="pc bpc" id="L601" title="1 of 2 branches missed.">				if (token != null) {</span>
<span class="fc" id="L602">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L603">					addToScoreMap(scoreMap, &quot;THVC&quot;, new BigDecimal(1));</span>
<span class="fc" id="L604">					token.set(getAnnotationClass(), scoreMap);</span>
				}
<span class="fc" id="L606">			}</span>
<span class="fc" id="L607">		}</span>
<span class="fc" id="L608">	}</span>

	
	public void annotate_THAC(Annotation annotation) {

<span class="fc" id="L613">		List&lt;String&gt; tags = Arrays.asList(&quot;that&quot;);</span>
<span class="fc" id="L614">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L615" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc" id="L616">			boolean wasJJ = false;</span>
<span class="fc bfc" id="L617" title="All 2 branches covered.">			for (CoreLabel token : sentence.tokens()) {</span>
<span class="fc bfc" id="L618" title="All 4 branches covered.">				if (tags.contains(token.lemma()) &amp;&amp; wasJJ) {</span>
<span class="fc" id="L619">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L620">					addToScoreMap(scoreMap, &quot;THAC&quot;, new BigDecimal(1));</span>
<span class="fc" id="L621">					token.set(getAnnotationClass(), scoreMap);</span>
<span class="fc" id="L622">				}</span>
<span class="fc bfc" id="L623" title="All 2 branches covered.">				else if (token.tag().equals(&quot;JJ&quot;)) {</span>
<span class="fc" id="L624">					wasJJ = true;</span>
				}
				else {
<span class="fc" id="L627">					wasJJ = false;</span>
				}
<span class="fc" id="L629">			}</span>
<span class="fc" id="L630">		}</span>
<span class="fc" id="L631">	}</span>


	public void annotate_WHCL(Annotation annotation) {
/*
(e.g. I believed what he told me)
This tag is assigned when the following pattern is found: any public, private or suasive verb
followed by any WH word, followed by a word that is NOT an auxiliary (tag MD for modal
verbs, or a form of DO, or a form of HAVE, or a form of BE). 
 */
<span class="fc" id="L641">		TokenSequencePattern pattern= TokenSequencePattern.compile(&quot;[{pos:WP}] [{pos:PRP} | {pos:NNP} | {pos:NNPS} | {pos:NN} | {pos:NNS}] [{pos:VB } | {pos:VBD} | {pos:VBG} | {pos:VBN} | {pos:VBP} | {pos:VBZ} ]&quot;);</span>
<span class="fc" id="L642">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L643" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc" id="L644">			List&lt;CoreLabel&gt; tokens = sentence.tokens();</span>

<span class="fc" id="L646">			TokenSequenceMatcher matcher = pattern.getMatcher(tokens);</span>
<span class="fc bfc" id="L647" title="All 2 branches covered.">			while (matcher.find()) {</span>
<span class="fc" id="L648">				List&lt;CoreMap&gt; matchedTokens = matcher.groupNodes();</span>
<span class="fc" id="L649">				CoreMap token = null;</span>
<span class="fc bfc" id="L650" title="All 2 branches covered.">				for (CoreMap t : matchedTokens) {</span>
<span class="fc" id="L651">					token = t;</span>
<span class="fc" id="L652">				}</span>
<span class="pc bpc" id="L653" title="1 of 2 branches missed.">				if (token != null) {</span>
<span class="fc" id="L654">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L655">					addToScoreMap(scoreMap, &quot;WHCL&quot;, new BigDecimal(1));</span>
<span class="fc" id="L656">					token.set(getAnnotationClass(), scoreMap);</span>
				}
<span class="fc" id="L658">			}</span>
<span class="fc" id="L659">		}</span>
<span class="fc" id="L660">	}</span>



	public void annotate_TO(Annotation annotation) {
/*
The tag for infinitives is the Stanford Tagger Treebank tag TO. The Stanford Tagger does not
distinguish when the word to is used as an infinitive marker or a preposition. Therefore, an
algorithm was implemented to identify instances of to as preposition. This algorithm finds
any occurrence of to followed by a subordinator (IN), a cardinal number (CD), a determiner
(DT), an adjective (JJ), a possessive pronoun (PRP$), WH words (WP$, WDT, WP, WRB), a
pre-determiner (PDT), a noun (N, NNS, NP, NPs), or a pronoun (PRP) and tags it as a
preposition. The remaining instances of to are considered as being infinitive markers and are
therefore identifying occurrences of infinitive clauses. 
 */
<span class="fc" id="L675">		TokenSequencePattern pattern= TokenSequencePattern.compile(&quot;[{pos:TO}] [{pos:VB}]&quot;);</span>
<span class="fc" id="L676">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L677" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc" id="L678">			List&lt;CoreLabel&gt; tokens = sentence.tokens();</span>

<span class="fc" id="L680">			TokenSequenceMatcher matcher = pattern.getMatcher(tokens);</span>
<span class="fc bfc" id="L681" title="All 2 branches covered.">			while (matcher.find()) {</span>
<span class="fc" id="L682">				List&lt;CoreMap&gt; matchedTokens = matcher.groupNodes();</span>
<span class="fc" id="L683">				CoreMap token = null;</span>
<span class="fc bfc" id="L684" title="All 2 branches covered.">				for (CoreMap t : matchedTokens) {</span>
<span class="fc" id="L685">					token = t;</span>
<span class="fc" id="L686">				}</span>
<span class="pc bpc" id="L687" title="1 of 2 branches missed.">				if (token != null) {</span>
<span class="fc" id="L688">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L689">					addToScoreMap(scoreMap, &quot;TO&quot;, new BigDecimal(1));</span>
<span class="fc" id="L690">					token.set(getAnnotationClass(), scoreMap);</span>
				}
<span class="fc" id="L692">			}</span>
<span class="fc" id="L693">		}</span>
<span class="fc" id="L694">	}</span>
	

	public void annotate_PRESP(Annotation annotation) {
/*
(e.g. Stuffing his mouth with cookies, Joe ran out the door)
This tag is assigned when the following pattern is found: a punctuation mark is followed by a
present participial form of a verb (VBG) followed by a preposition (PIN), a determiner (DT,
QUAN, CD), a WH pronoun, a WH possessive pronoun (WP$), any WH word, any pronoun
(PRP) or any adverb (RB). 
 */
<span class="fc" id="L705">		List&lt;String&gt; posTags = Arrays.asList(&quot;VBG&quot;);</span>
<span class="fc" id="L706">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L707" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc bfc" id="L708" title="All 2 branches covered.">			for (CoreLabel token : sentence.tokens()) {</span>
<span class="fc bfc" id="L709" title="All 2 branches covered.">				if (posTags.contains(token.tag())) {</span>
<span class="fc" id="L710">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L711">					addToScoreMap(scoreMap, &quot;PRESP&quot;, new BigDecimal(1));</span>
<span class="fc" id="L712">					token.set(getAnnotationClass(), scoreMap);</span>
				}
<span class="fc" id="L714">			}</span>
<span class="fc" id="L715">		}</span>
<span class="fc" id="L716">	}</span>

	
	public void annotate_PASTP(Annotation annotation) {
/*
(e.g. Built in a single week, the house would stand for fifty years)
This tag is assigned when the following pattern is found: a punctuation mark followed by a
past participial form of a verb (VBN) followed by a preposition (PIN) or an adverb (RB). 
 */
<span class="fc" id="L725">		List&lt;String&gt; posTags = Arrays.asList(&quot;VBN&quot;);</span>
<span class="fc" id="L726">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L727" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc bfc" id="L728" title="All 2 branches covered.">			for (CoreLabel token : sentence.tokens()) {</span>
<span class="fc bfc" id="L729" title="All 2 branches covered.">				if (posTags.contains(token.tag())) {</span>
<span class="fc" id="L730">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L731">					addToScoreMap(scoreMap, &quot;PASTP&quot;, new BigDecimal(1));</span>
<span class="fc" id="L732">					token.set(getAnnotationClass(), scoreMap);</span>
				}
<span class="fc" id="L734">			}</span>
<span class="fc" id="L735">		}</span>
<span class="fc" id="L736">	}</span>
	

	public void annotate_WZPAST(Annotation annotation) {
/*
(e.g. The solution produced by this process)
This tag is assigned when the following pattern is found: a noun (N) or quantifier pronoun
(QUPR) followed by a past participial form of a verb (VBN) followed by a preposition (PIN)
or an adverb (RB) or a form of BE. 
 */
<span class="fc" id="L746">		TokenSequencePattern pattern= TokenSequencePattern.compile(&quot;[{pos:NN} | {pos:NNS}] [{pos:VBN}] [{pos:IN} | {pos:RB} | {lemma:be}]&quot;);</span>
<span class="fc" id="L747">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L748" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc" id="L749">			List&lt;CoreLabel&gt; tokens = sentence.tokens();</span>

<span class="fc" id="L751">			TokenSequenceMatcher matcher = pattern.getMatcher(tokens);</span>
<span class="fc bfc" id="L752" title="All 2 branches covered.">			while (matcher.find()) {</span>
<span class="fc" id="L753">				List&lt;CoreMap&gt; matchedTokens = matcher.groupNodes();</span>
<span class="pc bpc" id="L754" title="1 of 2 branches missed.">				if (matchedTokens.size() == 3) {</span>
<span class="fc" id="L755">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(matchedTokens.get(1));</span>
<span class="fc" id="L756">					addToScoreMap(scoreMap, &quot;WZPAST&quot;, new BigDecimal(1));</span>
<span class="fc" id="L757">					matchedTokens.get(1).set(getAnnotationClass(), scoreMap);</span>
				}
<span class="fc" id="L759">			}</span>
<span class="fc" id="L760">		}</span>
<span class="fc" id="L761">	}</span>
	

	public void annotate_WZPRES(Annotation annotation) {
/*
(e.g. the event causing this decline is….)
This tag is assigned a present participial form of a verb (VBG) is preceded by a noun (NN).
 */
<span class="fc" id="L769">		TokenSequencePattern pattern= TokenSequencePattern.compile(&quot;[{pos:NN} | {pos:NNS}] [{pos:VBG}]&quot;);</span>
<span class="fc" id="L770">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L771" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc" id="L772">			List&lt;CoreLabel&gt; tokens = sentence.tokens();</span>
<span class="fc" id="L773">			TokenSequenceMatcher matcher = pattern.getMatcher(tokens);</span>
<span class="fc bfc" id="L774" title="All 2 branches covered.">			while (matcher.find()) {</span>
<span class="fc" id="L775">				List&lt;CoreMap&gt; matchedTokens = matcher.groupNodes();</span>
<span class="fc" id="L776">				CoreMap token = null;</span>
<span class="fc bfc" id="L777" title="All 2 branches covered.">				for (CoreMap t : matchedTokens) {</span>
<span class="fc" id="L778">					token = t;</span>
<span class="fc" id="L779">				}</span>
<span class="pc bpc" id="L780" title="1 of 2 branches missed.">				if (token != null) {</span>
<span class="fc" id="L781">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L782">					addToScoreMap(scoreMap, &quot;WZPRES&quot;, new BigDecimal(1));</span>
<span class="fc" id="L783">					token.set(getAnnotationClass(), scoreMap);</span>
				}
<span class="fc" id="L785">			}</span>
<span class="fc" id="L786">		}</span>
<span class="fc" id="L787">	}</span>
	

	public void annotate_TSUB(Annotation annotation) {
/*
(e.g. the dog that bit me)
These are occurrences of that preceded by a noun (N) and followed by an auxiliary verb or a
verb (V), with the possibility of an intervening adverb (RB) or negation (XX0). 
 */
<span class="fc" id="L796">		TokenSequencePattern pattern= TokenSequencePattern.compile(&quot;[that] [{pos:VB } | {pos:VBD} | {pos:VBG} | {pos:VBN} | {pos:VBP} | {pos:VBZ}]&quot;);</span>
<span class="fc" id="L797">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L798" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc" id="L799">			List&lt;CoreLabel&gt; tokens = sentence.tokens();</span>

<span class="fc" id="L801">			TokenSequenceMatcher matcher = pattern.getMatcher(tokens);</span>
<span class="fc bfc" id="L802" title="All 2 branches covered.">			while (matcher.find()) {</span>
<span class="fc" id="L803">				List&lt;CoreMap&gt; matchedTokens = matcher.groupNodes();</span>
<span class="fc" id="L804">				CoreMap token = null;</span>
<span class="fc" id="L805">				CoreMap thatToken = null;</span>
<span class="fc bfc" id="L806" title="All 2 branches covered.">				for (CoreMap t : matchedTokens) {</span>
<span class="fc" id="L807">					thatToken = token;</span>
<span class="fc" id="L808">					token = t;</span>
<span class="fc" id="L809">				}</span>
<span class="pc bpc" id="L810" title="1 of 2 branches missed.">				if (token != null) {</span>
<span class="fc" id="L811">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(thatToken);</span>
<span class="fc" id="L812">					addToScoreMap(scoreMap, &quot;TSUB&quot;, new BigDecimal(1));</span>
<span class="fc" id="L813">					thatToken.set(getAnnotationClass(), scoreMap);</span>
				}
<span class="fc" id="L815">			}</span>
<span class="fc" id="L816">		}</span>
<span class="fc" id="L817">	}</span>
	

	public void annotate_TOBJ(Annotation annotation) {
/*
(e.g. the dog that I saw)
These are occurrences of that preceded by a noun and followed by a determiner (DT, QUAN,
CD), a subject form of a personal pronoun, a possessive pronoun (PRP$), the pronoun it, an
adjective (JJ), a plural noun (NNS), a proper noun (NNP) or a possessive noun (a noun (N)
followed by a genitive marker (POS)). As Biber specifies, however, this algorithm does not
distinguish between simple complements to nouns and true relative clauses. 
 */
<span class="fc" id="L829">		TokenSequencePattern pattern= TokenSequencePattern.compile(&quot;[that] [{pos:NN } | {pos:NNP} | {pos:PRP}]&quot;);</span>
<span class="fc" id="L830">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L831" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc" id="L832">			List&lt;CoreLabel&gt; tokens = sentence.tokens();</span>

<span class="fc" id="L834">			TokenSequenceMatcher matcher = pattern.getMatcher(tokens);</span>
<span class="fc bfc" id="L835" title="All 2 branches covered.">			while (matcher.find()) {</span>
<span class="fc" id="L836">				List&lt;CoreMap&gt; matchedTokens = matcher.groupNodes();</span>
<span class="fc" id="L837">				CoreMap token = null;</span>
<span class="fc" id="L838">				CoreMap thatToken = null;</span>
<span class="fc bfc" id="L839" title="All 2 branches covered.">				for (CoreMap t : matchedTokens) {</span>
<span class="fc" id="L840">					thatToken = token;</span>
<span class="fc" id="L841">					token = t;</span>
<span class="fc" id="L842">				}</span>
<span class="pc bpc" id="L843" title="1 of 2 branches missed.">				if (token != null) {</span>
<span class="fc" id="L844">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(thatToken);</span>
<span class="fc" id="L845">					addToScoreMap(scoreMap, &quot;TOBJ&quot;, new BigDecimal(1));</span>
<span class="fc" id="L846">					thatToken.set(getAnnotationClass(), scoreMap);</span>
				}
<span class="fc" id="L848">			}</span>
<span class="fc" id="L849">		}</span>
<span class="fc" id="L850">	}</span>
	

	public void annotate_WHSUB(Annotation annotation) {
/*
(e.g. the man who likes popcorn)
This tag is assigned when the following pattern is found: any word that is NOT a form of the
words ASK or TELL followed by a noun (N), then a WH pronoun, then by any verb or
auxiliary verb (V), with the possibility of an intervening adverb (RB) or negation (XX0)
between the WH pronoun and the verb. 
 */
<span class="fc" id="L861">		TokenSequencePattern pattern= TokenSequencePattern.compile(&quot;[{pos:NN } | {pos:NNS} | {pos:NNP} | {pos:NNPS}] [{pos:WP}] [{pos:VB } | {pos:VBD} | {pos:VBG} | {pos:VBN} | {pos:VBP} | {pos:VBZ} ]&quot;);</span>
<span class="fc" id="L862">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L863" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc" id="L864">			List&lt;CoreLabel&gt; tokens = sentence.tokens();</span>

<span class="fc" id="L866">			TokenSequenceMatcher matcher = pattern.getMatcher(tokens);</span>
<span class="fc bfc" id="L867" title="All 2 branches covered.">			while (matcher.find()) {</span>
<span class="fc" id="L868">				List&lt;CoreMap&gt; matchedTokens = matcher.groupNodes();</span>
<span class="pc bpc" id="L869" title="1 of 2 branches missed.">				if (matchedTokens.size() == 3) {</span>
<span class="fc" id="L870">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(matchedTokens.get(1));</span>
<span class="fc" id="L871">					addToScoreMap(scoreMap, &quot;WHSUB&quot;, new BigDecimal(1));</span>
<span class="fc" id="L872">					matchedTokens.get(1).set(getAnnotationClass(), scoreMap);</span>
				}
<span class="fc" id="L874">			}</span>
<span class="fc" id="L875">		}</span>
<span class="fc" id="L876">	}</span>
	

	public void annotate_WHOBJ(Annotation annotation) {
/*
(e.g. the man who Sally likes)
This tag is assigned when the following pattern is found: any word that is NOT a form of the
words ASK or TELL followed by any word, followed by a noun (N), followed by any word
that is NOT an adverb (RB), a negation (XX0) , a verb or an auxiliary verb (MD, forms of
HAVE, BE or DO). 
 */
<span class="fc" id="L887">		TokenSequencePattern pattern= TokenSequencePattern.compile(&quot;[{pos:WP}] [{pos:NN } | {pos:NNP} | {pos:PRP}]&quot;);</span>
<span class="fc" id="L888">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L889" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc" id="L890">			List&lt;CoreLabel&gt; tokens = sentence.tokens();</span>

<span class="fc" id="L892">			TokenSequenceMatcher matcher = pattern.getMatcher(tokens);</span>
<span class="fc bfc" id="L893" title="All 2 branches covered.">			while (matcher.find()) {</span>
<span class="fc" id="L894">				List&lt;CoreMap&gt; matchedTokens = matcher.groupNodes();</span>
<span class="fc" id="L895">				CoreMap token = null;</span>
<span class="fc bfc" id="L896" title="All 2 branches covered.">				for (CoreMap t : matchedTokens) {</span>
<span class="fc" id="L897">					token = t;</span>
<span class="fc" id="L898">				}</span>
<span class="pc bpc" id="L899" title="1 of 2 branches missed.">				if (token != null) {</span>
<span class="fc" id="L900">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L901">					addToScoreMap(scoreMap, &quot;WHOBJ&quot;, new BigDecimal(1));</span>
<span class="fc" id="L902">					token.set(getAnnotationClass(), scoreMap);</span>
				}
<span class="fc" id="L904">			}</span>
<span class="fc" id="L905">		}</span>
<span class="fc" id="L906">	}</span>

	public void annotate_PIRE(Annotation annotation) {
		try {
<span class="fc" id="L910">			List&lt;String&gt; posTags = Arrays.asList(&quot;who&quot;, &quot;whom&quot;, &quot;whose&quot;, &quot;which&quot;);</span>
<span class="fc" id="L911">			List&lt;String&gt; tags = ResourceUtils.getInstance(getParameterStore()).getList(&quot;io/outofprintmagazine/nlp/models/Biber/PIN.txt&quot;);</span>
<span class="fc" id="L912">			CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L913" title="All 2 branches covered.">			for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc" id="L914">				boolean wasPIN = false;</span>
<span class="fc bfc" id="L915" title="All 2 branches covered.">				for (CoreLabel token : sentence.tokens()) {</span>
<span class="fc bfc" id="L916" title="All 4 branches covered.">					if (posTags.contains(token.lemma()) &amp;&amp; wasPIN) {</span>
<span class="fc" id="L917">						Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L918">						addToScoreMap(scoreMap, &quot;PIRE&quot;, new BigDecimal(1));</span>
<span class="fc" id="L919">						token.set(getAnnotationClass(), scoreMap);</span>
					}
<span class="fc bfc" id="L921" title="All 2 branches covered.">					if (tags.contains(token.lemma())) {</span>
<span class="fc" id="L922">						wasPIN = true;</span>
					}
					else {
<span class="fc" id="L925">						wasPIN = false;</span>
					}
<span class="fc" id="L927">				}</span>
<span class="fc" id="L928">			}</span>
		}
<span class="nc" id="L930">		catch (Throwable t) {</span>
<span class="nc" id="L931">			logger.error(t);</span>
<span class="fc" id="L932">		}</span>
<span class="fc" id="L933">	}</span>
	
	public void annotate_SERE(Annotation annotation) {
<span class="fc" id="L936">		List&lt;String&gt; tags = Arrays.asList(&quot;which&quot;);</span>
<span class="fc" id="L937">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L938" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc" id="L939">			boolean wasPunct = false;</span>
<span class="fc bfc" id="L940" title="All 2 branches covered.">			for (CoreLabel token : sentence.tokens()) {</span>
<span class="fc bfc" id="L941" title="All 4 branches covered.">				if (tags.contains(token.lemma()) &amp;&amp; wasPunct) {</span>
<span class="fc" id="L942">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L943">					addToScoreMap(scoreMap, &quot;SERE&quot;, new BigDecimal(1));</span>
<span class="fc" id="L944">					token.set(getAnnotationClass(), scoreMap);</span>
<span class="fc" id="L945">					break;</span>
				}
<span class="fc bfc" id="L947" title="All 2 branches covered.">				if (isPunctuationMark(token)) {</span>
<span class="fc" id="L948">					wasPunct = true;</span>
				}
				else {
<span class="fc" id="L951">					wasPunct = false;</span>
				}
<span class="fc" id="L953">			}</span>
<span class="fc" id="L954">		}</span>
<span class="fc" id="L955">	}</span>
	
	public void annotate_CAUS(Annotation annotation) {
<span class="fc" id="L958">		List&lt;String&gt; tags = Arrays.asList(&quot;because&quot;);</span>
<span class="fc" id="L959">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L960" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc bfc" id="L961" title="All 2 branches covered.">			for (CoreLabel token : sentence.tokens()) {</span>
<span class="fc bfc" id="L962" title="All 2 branches covered.">				if (tags.contains(token.lemma())) {</span>
<span class="fc" id="L963">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L964">					addToScoreMap(scoreMap, &quot;CAUS&quot;, new BigDecimal(1));</span>
<span class="fc" id="L965">					token.set(getAnnotationClass(), scoreMap);</span>
				}
<span class="fc" id="L967">			}</span>
<span class="fc" id="L968">		}</span>
<span class="fc" id="L969">	}</span>
	
	public void annotate_CONC(Annotation annotation) {
<span class="fc" id="L972">		List&lt;String&gt; tags = Arrays.asList(&quot;although&quot;, &quot;though&quot;, &quot;tho&quot;);</span>
<span class="fc" id="L973">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L974" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc bfc" id="L975" title="All 2 branches covered.">			for (CoreLabel token : sentence.tokens()) {</span>
<span class="fc bfc" id="L976" title="All 2 branches covered.">				if (tags.contains(token.lemma())) {</span>
<span class="fc" id="L977">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L978">					addToScoreMap(scoreMap, &quot;CONC&quot;, new BigDecimal(1));</span>
<span class="fc" id="L979">					token.set(getAnnotationClass(), scoreMap);</span>
				}
<span class="fc" id="L981">			}</span>
<span class="fc" id="L982">		}</span>
<span class="fc" id="L983">	}</span>
	
	public void annotate_COND(Annotation annotation) {
<span class="fc" id="L986">		List&lt;String&gt; tags = Arrays.asList(&quot;if&quot;, &quot;unless&quot;);</span>
<span class="fc" id="L987">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L988" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc bfc" id="L989" title="All 2 branches covered.">			for (CoreLabel token : sentence.tokens()) {</span>
<span class="fc bfc" id="L990" title="All 2 branches covered.">				if (tags.contains(token.lemma())) {</span>
<span class="fc" id="L991">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L992">					addToScoreMap(scoreMap, &quot;COND&quot;, new BigDecimal(1));</span>
<span class="fc" id="L993">					token.set(getAnnotationClass(), scoreMap);</span>
				}
<span class="fc" id="L995">			}</span>
<span class="fc" id="L996">		}</span>
<span class="fc" id="L997">	}</span>
	

	public void annotate_OSUB(Annotation annotation) {
/*
This tag identifies any occurrence of the words: since, while, whilst, whereupon, whereas,
whereby, such that, so that (followed by a word that is neither a noun nor an adjective), such
that (followed by a word that is neither a noun nor an adjective), inasmuch as, forasmuch as,
insofar as, insomuch as, as long as, as soon as. In cases of multi-word units such as as long
as, only the first word is tagged as OSUB and the other words are tagged with the tag NULL.
 */
<span class="fc" id="L1008">		List&lt;String&gt; tags = Arrays.asList(&quot;since&quot;, &quot;while&quot;, &quot;whilst&quot;, &quot;whereupon&quot;, &quot;whereas&quot;, &quot;whereby&quot;, &quot;inasmuch&quot;, &quot;forasmuch&quot;, &quot;insofar&quot;, &quot;insomuch&quot;);</span>
<span class="fc" id="L1009">		List&lt;String&gt; posTags = Arrays.asList(&quot;NN&quot;, &quot;NNS&quot;, &quot;NNP&quot;,&quot;NNPS&quot;, &quot;JJ&quot;, &quot;JJR&quot;, &quot;JJS&quot;);</span>
<span class="fc" id="L1010">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L1011" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc bfc" id="L1012" title="All 2 branches covered.">			for (int i=0;i&lt;sentence.tokens().size();i++) {</span>
<span class="fc bfc" id="L1013" title="All 2 branches covered.">				if (tags.contains(sentence.tokens().get(i).lemma())) {</span>
<span class="fc" id="L1014">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(sentence.tokens().get(i));</span>
<span class="fc" id="L1015">					addToScoreMap(scoreMap, &quot;OSUB&quot;, new BigDecimal(1));</span>
<span class="fc" id="L1016">					sentence.tokens().get(i).set(getAnnotationClass(), scoreMap);</span>
				}
<span class="fc bfc" id="L1018" title="All 2 branches covered.">				if (i&lt;sentence.tokens().size()-2) {</span>
<span class="pc bpc" id="L1019" title="3 of 8 branches missed.">					if ((sentence.tokens().get(i).lemma().equals(&quot;such&quot;) || sentence.tokens().get(i).lemma().equals(&quot;so&quot;)) &amp;&amp; sentence.tokens().get(i+1).lemma().equals(&quot;that&quot;) &amp;&amp; !posTags.contains(sentence.tokens().get(i+2).tag())) {</span>
<span class="nc" id="L1020">						Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(sentence.tokens().get(i));</span>
<span class="nc" id="L1021">						addToScoreMap(scoreMap, &quot;OSUB&quot;, new BigDecimal(1));</span>
<span class="nc" id="L1022">						sentence.tokens().get(i).set(getAnnotationClass(), scoreMap);</span>
					}					
				}
			}
<span class="fc" id="L1026">		}</span>
<span class="fc" id="L1027">	}</span>
	
	public void annotate_PIN(Annotation annotation) {
		try {
<span class="fc" id="L1031">			List&lt;String&gt; tags = ResourceUtils.getInstance(getParameterStore()).getList(&quot;io/outofprintmagazine/nlp/models/Biber/PIN.txt&quot;);</span>
<span class="fc" id="L1032">			CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L1033" title="All 2 branches covered.">			for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc bfc" id="L1034" title="All 2 branches covered.">				for (CoreLabel token : sentence.tokens()) {</span>
<span class="fc bfc" id="L1035" title="All 2 branches covered.">					if (tags.contains(token.lemma())) {</span>
<span class="fc" id="L1036">						Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L1037">						addToScoreMap(scoreMap, &quot;PIN&quot;, new BigDecimal(1));</span>
<span class="fc" id="L1038">						token.set(getAnnotationClass(), scoreMap);</span>
					}
<span class="fc" id="L1040">				}</span>
<span class="fc" id="L1041">			}</span>
		}
<span class="nc" id="L1043">		catch (Throwable t) {</span>
<span class="nc" id="L1044">			logger.error(t);</span>
<span class="fc" id="L1045">		}</span>
<span class="fc" id="L1046">	}</span>
	
	public void annotate_JJ(Annotation annotation) {
<span class="fc" id="L1049">		List&lt;String&gt; posTags = Arrays.asList(&quot;JJ&quot;, &quot;JJS&quot;, &quot;JJR&quot;);</span>
<span class="fc" id="L1050">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L1051" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc bfc" id="L1052" title="All 2 branches covered.">			for (CoreLabel token : sentence.tokens()) {</span>
<span class="fc bfc" id="L1053" title="All 2 branches covered.">				if (posTags.contains(token.tag())) {</span>
<span class="fc" id="L1054">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L1055">					addToScoreMap(scoreMap, &quot;JJ&quot;, new BigDecimal(1));</span>
<span class="fc" id="L1056">					token.set(getAnnotationClass(), scoreMap);</span>
				}
<span class="fc" id="L1058">			}</span>
<span class="fc" id="L1059">		}</span>
<span class="fc" id="L1060">	}</span>
	

	public void annotate_PRED(Annotation annotation) {
/*
(e.g. the horse is big)
The tagger tags as PRED the adjectives that are found in the following pattern: any form of
BE followed by an adjective (JJ) followed by a word that is NOT another adjective, an
adverb (RB) or a noun (N). If any adverb or negation is intervening between the adjective and
the word after it, the tag is still assigned. A modification to Biber’s algorithm was
implemented in the present tagger to improve its accuracy. An adjective is tagged as
predicative if it is preceded by another predicative adjective followed by a phrasal
coordinator (see below). This pattern accounts for cases such as: the horse is big and fast. 
 */
<span class="fc" id="L1074">		List&lt;String&gt; posTags = Arrays.asList(&quot;JJ&quot;);</span>
<span class="fc" id="L1075">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L1076" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc" id="L1077">			boolean wasBe = false;</span>
<span class="fc bfc" id="L1078" title="All 2 branches covered.">			for (CoreLabel token : sentence.tokens()) {</span>
<span class="fc bfc" id="L1079" title="All 4 branches covered.">				if (posTags.contains(token.tag()) &amp;&amp; wasBe) {</span>
<span class="fc" id="L1080">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L1081">					addToScoreMap(scoreMap, &quot;PRED&quot;, new BigDecimal(1));</span>
<span class="fc" id="L1082">					token.set(getAnnotationClass(), scoreMap);</span>
				}
<span class="fc bfc" id="L1084" title="All 2 branches covered.">				if (token.lemma().equals(&quot;be&quot;)) {</span>
<span class="fc" id="L1085">					wasBe = true;</span>
				}
				else {
<span class="fc" id="L1088">					wasBe = false;</span>
				}
<span class="fc" id="L1090">			}</span>
<span class="fc" id="L1091">		}</span>
<span class="fc" id="L1092">	}</span>
	
	public void annotate_RB(Annotation annotation) {
<span class="fc" id="L1095">		List&lt;String&gt; posTags = Arrays.asList(&quot;RB&quot;, &quot;RBS&quot;, &quot;RBR&quot;, &quot;WRB&quot;);</span>
<span class="fc" id="L1096">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L1097" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc bfc" id="L1098" title="All 2 branches covered.">			for (CoreLabel token : sentence.tokens()) {</span>
<span class="fc bfc" id="L1099" title="All 2 branches covered.">				if (posTags.contains(token.tag())) {</span>
<span class="fc" id="L1100">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L1101">					addToScoreMap(scoreMap, &quot;RB&quot;, new BigDecimal(1));</span>
<span class="fc" id="L1102">					token.set(getAnnotationClass(), scoreMap);</span>
				}
<span class="fc" id="L1104">			}</span>
<span class="fc" id="L1105">		}</span>
<span class="fc" id="L1106">	}</span>
	
	public void annotate_AWL(Annotation annotation) {
<span class="fc" id="L1109">		int words = 0;</span>
<span class="fc" id="L1110">		int characters = 0;</span>
<span class="fc" id="L1111">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L1112" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc bfc" id="L1113" title="All 2 branches covered.">			for (CoreLabel token : sentence.tokens()) {</span>
<span class="fc bfc" id="L1114" title="All 2 branches covered.">				if (!isPunctuationMark(token)) {</span>
<span class="fc" id="L1115">					words++;</span>
<span class="fc" id="L1116">					characters += token.originalText().length();</span>
				}
<span class="fc" id="L1118">			}</span>
<span class="fc" id="L1119">		}</span>
		try {
<span class="pc bpc" id="L1121" title="2 of 4 branches missed.">			if (characters &gt; 0 &amp;&amp; words &gt; 0) {</span>
<span class="fc" id="L1122">				Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(annotation);</span>
<span class="fc" id="L1123">				addToScoreMap(scoreMap, &quot;AWL&quot;, new BigDecimal(characters/words));</span>
<span class="fc" id="L1124">				annotation.set(getAnnotationClass(), scoreMap);</span>
			}
		}
<span class="nc" id="L1127">		catch (Exception e) {</span>
<span class="nc" id="L1128">			logger.error(e);</span>
<span class="fc" id="L1129">		}</span>
<span class="fc" id="L1130">	}</span>
	
	public void annotate_TTR(Annotation annotation) {
<span class="fc" id="L1133">		int words = 0;</span>
<span class="fc" id="L1134">		List&lt;String&gt; typeCount = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L1135">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L1136" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="pc bpc" id="L1137" title="1 of 2 branches missed.">			if (words &gt; 400) {</span>
<span class="nc" id="L1138">				break;</span>
			}
<span class="fc bfc" id="L1140" title="All 2 branches covered.">			for (CoreLabel token : sentence.tokens()) {</span>
<span class="fc bfc" id="L1141" title="All 2 branches covered.">				if (!isPunctuationMark(token)) {</span>
<span class="fc" id="L1142">					words++;</span>
<span class="fc" id="L1143">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(annotation);</span>
<span class="fc bfc" id="L1144" title="All 2 branches covered.">					for (String key : scoreMap.keySet()) {</span>
<span class="fc bfc" id="L1145" title="All 2 branches covered.">						if (!typeCount.contains(key)) {</span>
<span class="fc" id="L1146">							typeCount.add(key);</span>
						}
						
<span class="fc" id="L1149">					}</span>
				}
<span class="fc" id="L1151">			}</span>
<span class="fc" id="L1152">		}</span>
		try {
<span class="pc bpc" id="L1154" title="1 of 2 branches missed.">			if (words &gt; 0) {</span>
<span class="fc" id="L1155">				Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(annotation);</span>
<span class="fc" id="L1156">				addToScoreMap(scoreMap, &quot;TTR&quot;, new BigDecimal(typeCount.size()/words));</span>
<span class="fc" id="L1157">				annotation.set(getAnnotationClass(), scoreMap);</span>
			}
		}
<span class="nc" id="L1160">		catch (Exception e) {</span>
<span class="nc" id="L1161">			logger.error(e);</span>
<span class="fc" id="L1162">		}</span>
<span class="fc" id="L1163">	}</span>
	

	public void annotate_CONJ(Annotation annotation) {
/*
This tag finds any of the items in this list: punctuation+else, punctuation+altogether,
punctuation+rather, alternatively, consequently, conversely, e.g., furthermore, hence,
however, i.e., instead, likewise, moreover, namely, nevertheless, nonetheless,
notwithstanding, otherwise, similarly, therefore, thus, viz., in comparison, in contrast, in
particular, in addition, in conclusion, in consequence, in sum, in summary, for example, for 
instance, instead of, by contrast, by comparison, in any event, in any case, in other words, as
a result, as a consequence, on the contrary, on the other hand.
Some minor inconsistencies in the said list were fixed. For example, Biber lists the word
rather two times in this list, making the second mentions redundant. Rather was counted only
when it appeared after a punctuation mark. The same applies for altogether. In cases of multiword units such as on the other hand, only the first word is tagged as OSUB and the other
words are tagged with the tag NULL. 
 */
		try {
<span class="fc" id="L1181">			List&lt;String&gt; tags = ResourceUtils.getInstance(getParameterStore()).getList(&quot;io/outofprintmagazine/nlp/models/Biber/CONJ.txt&quot;);;</span>
<span class="fc" id="L1182">			CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L1183" title="All 2 branches covered.">			for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc bfc" id="L1184" title="All 2 branches covered.">				for (CoreLabel token : sentence.tokens()) {</span>
<span class="fc bfc" id="L1185" title="All 2 branches covered.">					if (tags.contains(token.lemma())) {</span>
<span class="fc" id="L1186">						Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L1187">						addToScoreMap(scoreMap, &quot;CONJ&quot;, new BigDecimal(1));</span>
<span class="fc" id="L1188">						token.set(getAnnotationClass(), scoreMap);</span>
					}
<span class="fc" id="L1190">				}</span>
<span class="fc" id="L1191">			}</span>
		}
<span class="nc" id="L1193">		catch (Exception e) {</span>
<span class="nc" id="L1194">			logger.error(e);</span>
<span class="fc" id="L1195">		}</span>
<span class="fc" id="L1196">	}</span>
	
	public void annotate_DWNT(Annotation annotation) {
<span class="fc" id="L1199">		List&lt;String&gt; tags = Arrays.asList(&quot;almost&quot;, &quot;barely&quot;, &quot;hardly&quot;, &quot;merely&quot;, &quot;mildly&quot;, &quot;nearly&quot;, &quot;only&quot;, &quot;partially&quot;, &quot;partly&quot;, &quot;practically&quot;, &quot;scarcely&quot;, &quot;slightly&quot;, &quot;somewhat&quot;);</span>
<span class="fc" id="L1200">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L1201" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc bfc" id="L1202" title="All 2 branches covered.">			for (CoreLabel token : sentence.tokens()) {</span>
<span class="fc bfc" id="L1203" title="All 2 branches covered.">				if (tags.contains(token.lemma())) {</span>
<span class="fc" id="L1204">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L1205">					addToScoreMap(scoreMap, &quot;DWNT&quot;, new BigDecimal(1));</span>
<span class="fc" id="L1206">					token.set(getAnnotationClass(), scoreMap);</span>
				}
<span class="fc" id="L1208">			}</span>
<span class="fc" id="L1209">		}</span>
<span class="fc" id="L1210">	}</span>
	

	public void annotate_HDG(Annotation annotation) {
/*
This tag finds any of the items in this list: maybe, at about, something like, more or less, sort
of, kind of (these two items must be preceded by a determiner (DT), a quantifier (QUAN), a
cardinal number (CD), an adjective (JJ or PRED), a possessive pronouns (PRP$) or WH word
(see entry on WH-questions)). In cases of multi-word units such as more or less, only the first
word is tagged as HDG and the other words are tagged with the tag NULL. 
 */
<span class="fc" id="L1221">		List&lt;String&gt; posTags = Arrays.asList(&quot;NN&quot;, &quot;NNS&quot;, &quot;NNP&quot;, &quot;NNPS&quot;);</span>
<span class="fc" id="L1222">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L1223" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc bfc" id="L1224" title="All 2 branches covered.">			for (int i=0;i&lt;sentence.tokens().size();i++) {</span>
<span class="fc bfc" id="L1225" title="All 2 branches covered.">				if (sentence.tokens().get(i).lemma().equals(&quot;maybe&quot;)) {</span>
<span class="fc" id="L1226">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(sentence.tokens().get(i));</span>
<span class="fc" id="L1227">					addToScoreMap(scoreMap, &quot;HDG&quot;, new BigDecimal(1));</span>
<span class="fc" id="L1228">					sentence.tokens().get(i).set(getAnnotationClass(), scoreMap);</span>
				}
<span class="fc bfc" id="L1230" title="All 2 branches covered.">				if (i&lt;sentence.tokens().size()-1) {</span>
<span class="pc bpc" id="L1231" title="1 of 4 branches missed.">					if (sentence.tokens().get(i).lemma().equals(&quot;at&quot;) &amp;&amp; sentence.tokens().get(i+1).lemma().equals(&quot;about&quot;)) {</span>
<span class="nc" id="L1232">						Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(sentence.tokens().get(i));</span>
<span class="nc" id="L1233">						addToScoreMap(scoreMap, &quot;HDG&quot;, new BigDecimal(1));</span>
<span class="nc" id="L1234">						sentence.tokens().get(i).set(getAnnotationClass(), scoreMap);</span>
					}
<span class="pc bpc" id="L1236" title="3 of 4 branches missed.">					if (sentence.tokens().get(i).lemma().equals(&quot;something&quot;) &amp;&amp; sentence.tokens().get(i+1).lemma().equals(&quot;like&quot;)) {</span>
<span class="nc" id="L1237">						Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(sentence.tokens().get(i));</span>
<span class="nc" id="L1238">						addToScoreMap(scoreMap, &quot;HDG&quot;, new BigDecimal(1));</span>
<span class="nc" id="L1239">						sentence.tokens().get(i).set(getAnnotationClass(), scoreMap);</span>
					}
				}
<span class="fc bfc" id="L1242" title="All 2 branches covered.">				if (i&lt;sentence.tokens().size()-2) {				</span>
<span class="pc bpc" id="L1243" title="5 of 6 branches missed.">					if (sentence.tokens().get(i).lemma().equals(&quot;more&quot;) &amp;&amp; sentence.tokens().get(i+1).lemma().equals(&quot;or&quot;) &amp;&amp; sentence.tokens().get(i+2).lemma().equals(&quot;less&quot;)) {</span>
<span class="nc" id="L1244">						Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(sentence.tokens().get(i));</span>
<span class="nc" id="L1245">						addToScoreMap(scoreMap, &quot;HDG&quot;, new BigDecimal(1));</span>
<span class="nc" id="L1246">						sentence.tokens().get(i).set(getAnnotationClass(), scoreMap);</span>
					}
<span class="pc bpc" id="L1248" title="6 of 8 branches missed.">					if ((sentence.tokens().get(i).lemma().equals(&quot;sort&quot;) || sentence.tokens().get(i).lemma().equals(&quot;kind&quot;)) &amp;&amp; sentence.tokens().get(i+1).lemma().equals(&quot;of&quot;) &amp;&amp; !posTags.contains(sentence.tokens().get(i+2).tag())) {</span>
<span class="nc" id="L1249">						Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(sentence.tokens().get(i));</span>
<span class="nc" id="L1250">						addToScoreMap(scoreMap, &quot;HDG&quot;, new BigDecimal(1));</span>
<span class="nc" id="L1251">						sentence.tokens().get(i).set(getAnnotationClass(), scoreMap);</span>
					}
				}
			}
<span class="fc" id="L1255">		}</span>
<span class="fc" id="L1256">	}</span>
	
	public void annotate_AMP(Annotation annotation) {
<span class="fc" id="L1259">		List&lt;String&gt; tags = Arrays.asList(&quot;absolutely&quot;, &quot;altogether&quot;, &quot;completely&quot;, &quot;enormously&quot;, &quot;entirely&quot;, &quot;extremely&quot;, &quot;fully&quot;, &quot;greatly&quot;, &quot;highly&quot;, &quot;intensely&quot;, &quot;perfectly&quot;, &quot;strongly&quot;, &quot;thoroughly&quot;, &quot;totally&quot;,	&quot;utterly&quot;, &quot;very&quot;);</span>
<span class="fc" id="L1260">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L1261" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc bfc" id="L1262" title="All 2 branches covered.">			for (CoreLabel token : sentence.tokens()) {</span>
<span class="fc bfc" id="L1263" title="All 2 branches covered.">				if (tags.contains(token.lemma())) {</span>
<span class="fc" id="L1264">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L1265">					addToScoreMap(scoreMap, &quot;AMP&quot;, new BigDecimal(1));</span>
<span class="fc" id="L1266">					token.set(getAnnotationClass(), scoreMap);</span>
				}
<span class="fc" id="L1268">			}</span>
<span class="fc" id="L1269">		}</span>
<span class="fc" id="L1270">	}</span>
	

	public void annotate_EMPH(Annotation annotation) {
/*
This tag finds any of the items in this list: just, really, most, more, real+adjective,
so+adjective, any form of DO followed by a verb, for sure, a lot, such a. In cases of multiword units such as a lot, only the first word is tagged as OSUB and the other words are
tagged with the tag NULL. 
 */
<span class="fc" id="L1279">		List&lt;String&gt; tags = Arrays.asList(&quot;just&quot;, &quot;really&quot;, &quot;most&quot;, &quot;more&quot;);</span>
<span class="fc" id="L1280">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L1281" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc bfc" id="L1282" title="All 2 branches covered.">			for (int i=0;i&lt;sentence.tokens().size();i++) {</span>
<span class="fc bfc" id="L1283" title="All 2 branches covered.">				if (tags.contains(sentence.tokens().get(i).lemma())) {</span>
<span class="fc" id="L1284">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(sentence.tokens().get(i));</span>
<span class="fc" id="L1285">					addToScoreMap(scoreMap, &quot;EMPH&quot;, new BigDecimal(1));</span>
<span class="fc" id="L1286">					sentence.tokens().get(i).set(getAnnotationClass(), scoreMap);</span>
				}
<span class="fc bfc" id="L1288" title="All 2 branches covered.">				if (i&lt;sentence.tokens().size()-1) {</span>
<span class="fc" id="L1289">					if (</span>
<span class="pc bpc" id="L1290" title="1 of 4 branches missed.">							(sentence.tokens().get(i).lemma().equals(&quot;for&quot;) &amp;&amp; sentence.tokens().get(i+1).lemma().equals(&quot;sure&quot;))</span>
							||
<span class="pc bpc" id="L1292" title="1 of 4 branches missed.">							(sentence.tokens().get(i).lemma().equals(&quot;a&quot;) &amp;&amp; sentence.tokens().get(i+1).lemma().equals(&quot;lot&quot;))</span>
							||
<span class="pc bpc" id="L1294" title="1 of 4 branches missed.">							(sentence.tokens().get(i).lemma().equals(&quot;such&quot;) &amp;&amp; sentence.tokens().get(i+1).lemma().equals(&quot;a&quot;))</span>
							||
<span class="pc bpc" id="L1296" title="3 of 4 branches missed.">							(sentence.tokens().get(i).lemma().equals(&quot;real&quot;) &amp;&amp; sentence.tokens().get(i+1).tag().equals(&quot;JJ&quot;))</span>
							||
<span class="pc bpc" id="L1298" title="1 of 4 branches missed.">							(sentence.tokens().get(i).lemma().equals(&quot;so&quot;) &amp;&amp; sentence.tokens().get(i+1).lemma().equals(&quot;JJ&quot;))</span>
							||
<span class="pc bpc" id="L1300" title="1 of 4 branches missed.">							(sentence.tokens().get(i).lemma().equals(&quot;do&quot;) &amp;&amp; sentence.tokens().get(i+1).tag().startsWith(&quot;V&quot;))</span>
						) {
<span class="nc" id="L1302">						Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(sentence.tokens().get(i));</span>
<span class="nc" id="L1303">						addToScoreMap(scoreMap, &quot;EMPH&quot;, new BigDecimal(1));</span>
<span class="nc" id="L1304">						sentence.tokens().get(i).set(getAnnotationClass(), scoreMap);</span>
					}
				}
			}
<span class="fc" id="L1308">		}</span>

<span class="fc" id="L1310">	}</span>
	
	public void annotate_DPAR(Annotation annotation) {
<span class="fc" id="L1313">		List&lt;String&gt; tags = Arrays.asList(&quot;well&quot;, &quot;now&quot;, &quot;anyhow&quot;, &quot;anyways&quot;);</span>
<span class="fc" id="L1314">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L1315" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc" id="L1316">			boolean wasPunct = false;</span>
<span class="fc bfc" id="L1317" title="All 2 branches covered.">			for (CoreLabel token : sentence.tokens()) {</span>
<span class="fc bfc" id="L1318" title="All 4 branches covered.">				if (tags.contains(token.lemma()) &amp;&amp; wasPunct) {</span>
<span class="fc" id="L1319">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L1320">					addToScoreMap(scoreMap, &quot;DPAR&quot;, new BigDecimal(1));</span>
<span class="fc" id="L1321">					token.set(getAnnotationClass(), scoreMap);</span>
				}
<span class="fc bfc" id="L1323" title="All 2 branches covered.">				if (isPunctuationMark(token)) {</span>
<span class="fc" id="L1324">					wasPunct = true;</span>
				}
				else {
<span class="fc" id="L1327">					wasPunct = false;</span>
				}
<span class="fc" id="L1329">			}</span>
<span class="fc" id="L1330">		}</span>
<span class="fc" id="L1331">	}</span>
	
	//DONE - Must run after DEMP, TOBJ, TSUB, THAC, THVC
	public void annotate_DEMO(Annotation annotation) {
<span class="fc" id="L1335">		List&lt;String&gt; tags = Arrays.asList(&quot;this&quot;, &quot;that&quot;, &quot;these&quot;, &quot;those&quot;);</span>
<span class="fc" id="L1336">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L1337" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc bfc" id="L1338" title="All 2 branches covered.">			for (CoreLabel token : sentence.tokens()) {</span>
<span class="fc bfc" id="L1339" title="All 2 branches covered.">				if (tags.contains(token.lemma())) {</span>
<span class="fc" id="L1340">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="pc bpc" id="L1341" title="2 of 10 branches missed.">					if (scoreMap.get(&quot;DEMP&quot;) == null &amp;&amp; scoreMap.get(&quot;TOBJ&quot;) == null &amp;&amp; scoreMap.get(&quot;TSUB&quot;) == null &amp;&amp; scoreMap.get(&quot;THAC&quot;) == null &amp;&amp; scoreMap.get(&quot;THVC&quot;) == null) {</span>
<span class="fc" id="L1342">						addToScoreMap(scoreMap, &quot;DEMO&quot;, new BigDecimal(1));</span>
<span class="fc" id="L1343">						token.set(getAnnotationClass(), scoreMap);</span>
					}
				}
<span class="fc" id="L1346">			}</span>
<span class="fc" id="L1347">		}</span>
<span class="fc" id="L1348">	}</span>
	
	public void annotate_POMD(Annotation annotation) {
<span class="fc" id="L1351">		List&lt;String&gt; tags = Arrays.asList(&quot;can&quot;, &quot;may&quot;, &quot;might&quot;, &quot;could&quot;);</span>
<span class="fc" id="L1352">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L1353" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc bfc" id="L1354" title="All 2 branches covered.">			for (CoreLabel token : sentence.tokens()) {</span>
<span class="fc bfc" id="L1355" title="All 2 branches covered.">				if (tags.contains(token.lemma())) {</span>
<span class="fc" id="L1356">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L1357">					addToScoreMap(scoreMap, &quot;POMD&quot;, new BigDecimal(1));</span>
<span class="fc" id="L1358">					token.set(getAnnotationClass(), scoreMap);</span>
				}
<span class="fc" id="L1360">			}</span>
<span class="fc" id="L1361">		}</span>
<span class="fc" id="L1362">	}</span>
	
	public void annotate_NEMD(Annotation annotation) {
<span class="fc" id="L1365">		List&lt;String&gt; tags = Arrays.asList(&quot;ought&quot;, &quot;should&quot;, &quot;must&quot;);</span>
<span class="fc" id="L1366">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L1367" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc bfc" id="L1368" title="All 2 branches covered.">			for (CoreLabel token : sentence.tokens()) {</span>
<span class="fc bfc" id="L1369" title="All 2 branches covered.">				if (tags.contains(token.lemma())) {</span>
<span class="fc" id="L1370">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L1371">					addToScoreMap(scoreMap, &quot;NEMD&quot;, new BigDecimal(1));</span>
<span class="fc" id="L1372">					token.set(getAnnotationClass(), scoreMap);</span>
				}
<span class="fc" id="L1374">			}</span>
<span class="fc" id="L1375">		}</span>
<span class="fc" id="L1376">	}</span>
	
	public void annotate_PRMD(Annotation annotation) {
<span class="fc" id="L1379">		List&lt;String&gt; tags = Arrays.asList(&quot;will&quot;, &quot;would&quot;, &quot;shall&quot;);</span>
<span class="fc" id="L1380">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L1381" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc bfc" id="L1382" title="All 2 branches covered.">			for (CoreLabel token : sentence.tokens()) {</span>
<span class="fc bfc" id="L1383" title="All 2 branches covered.">				if (tags.contains(token.lemma())) {</span>
<span class="fc" id="L1384">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L1385">					addToScoreMap(scoreMap, &quot;PRMD&quot;, new BigDecimal(1));</span>
<span class="fc" id="L1386">					token.set(getAnnotationClass(), scoreMap);</span>
				}
<span class="fc" id="L1388">			}</span>
<span class="fc" id="L1389">		}</span>
<span class="fc" id="L1390">	}</span>
	
	public void annotate_PUBV(Annotation annotation) {
		try {
<span class="fc" id="L1394">			List&lt;String&gt; posTags = Arrays.asList(&quot;VB&quot;, &quot;VBD&quot;, &quot;VBG&quot;, &quot;VBN&quot;, &quot;VBP&quot;, &quot;VBZ&quot;);</span>
<span class="fc" id="L1395">			List&lt;String&gt; tags = ResourceUtils.getInstance(getParameterStore()).getList(&quot;io/outofprintmagazine/nlp/models/Biber/PUBV.txt&quot;);</span>
<span class="fc" id="L1396">			CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L1397" title="All 2 branches covered.">			for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc bfc" id="L1398" title="All 2 branches covered.">				for (CoreLabel token : sentence.tokens()) {</span>
<span class="fc bfc" id="L1399" title="All 4 branches covered.">					if (posTags.contains(token.tag()) &amp;&amp; tags.contains(token.lemma())) {</span>
<span class="fc" id="L1400">						Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L1401">						addToScoreMap(scoreMap, &quot;PUBV&quot;, new BigDecimal(1));</span>
<span class="fc" id="L1402">						token.set(getAnnotationClass(), scoreMap);</span>
					}
<span class="fc" id="L1404">				}</span>
<span class="fc" id="L1405">			}</span>
		}
<span class="nc" id="L1407">		catch (Throwable t) {</span>
<span class="nc" id="L1408">			logger.error(t);</span>
<span class="fc" id="L1409">		}</span>
<span class="fc" id="L1410">	}</span>
	
	public void annotate_PRIV(Annotation annotation) {
		try {
<span class="fc" id="L1414">			List&lt;String&gt; posTags = Arrays.asList(&quot;VB&quot;, &quot;VBD&quot;, &quot;VBG&quot;, &quot;VBN&quot;, &quot;VBP&quot;, &quot;VBZ&quot;);</span>
<span class="fc" id="L1415">			List&lt;String&gt; tags = ResourceUtils.getInstance(getParameterStore()).getList(&quot;io/outofprintmagazine/nlp/models/Biber/PRIV.txt&quot;);</span>
<span class="fc" id="L1416">			CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L1417" title="All 2 branches covered.">			for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc bfc" id="L1418" title="All 2 branches covered.">				for (CoreLabel token : sentence.tokens()) {</span>
<span class="fc bfc" id="L1419" title="All 4 branches covered.">					if (posTags.contains(token.tag()) &amp;&amp; tags.contains(token.lemma())) {</span>
<span class="fc" id="L1420">						Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L1421">						addToScoreMap(scoreMap, &quot;PRIV&quot;, new BigDecimal(1));</span>
<span class="fc" id="L1422">						token.set(getAnnotationClass(), scoreMap);</span>
					}
<span class="fc" id="L1424">				}</span>
<span class="fc" id="L1425">			}</span>
		}
<span class="nc" id="L1427">		catch (Throwable t) {</span>
<span class="nc" id="L1428">			logger.error(t);</span>
<span class="fc" id="L1429">		}</span>
<span class="fc" id="L1430">	}</span>
	
	public void annotate_SUAV(Annotation annotation) {
		try {
<span class="fc" id="L1434">			List&lt;String&gt; posTags = Arrays.asList(&quot;VB&quot;, &quot;VBD&quot;, &quot;VBG&quot;, &quot;VBN&quot;, &quot;VBP&quot;, &quot;VBZ&quot;);</span>
<span class="fc" id="L1435">			List&lt;String&gt; tags = ResourceUtils.getInstance(getParameterStore()).getList(&quot;io/outofprintmagazine/nlp/models/Biber/SUAV.txt&quot;);</span>
<span class="fc" id="L1436">			CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L1437" title="All 2 branches covered.">			for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc bfc" id="L1438" title="All 2 branches covered.">				for (CoreLabel token : sentence.tokens()) {</span>
<span class="fc bfc" id="L1439" title="All 4 branches covered.">					if (posTags.contains(token.tag()) &amp;&amp; tags.contains(token.lemma())) {</span>
<span class="fc" id="L1440">						Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L1441">						addToScoreMap(scoreMap, &quot;SUAV&quot;, new BigDecimal(1));</span>
<span class="fc" id="L1442">						token.set(getAnnotationClass(), scoreMap);</span>
					}
<span class="fc" id="L1444">				}</span>
<span class="fc" id="L1445">			}</span>
		}
<span class="nc" id="L1447">		catch (Throwable t) {</span>
<span class="nc" id="L1448">			logger.error(t);</span>
<span class="fc" id="L1449">		}</span>
<span class="fc" id="L1450">	}</span>
	
	
	public void annotate_SEMP(Annotation annotation) {
		try {
<span class="fc" id="L1455">			List&lt;String&gt; posTags = Arrays.asList(&quot;VB&quot;, &quot;VBD&quot;, &quot;VBG&quot;, &quot;VBN&quot;, &quot;VBP&quot;, &quot;VBZ&quot;);</span>
<span class="fc" id="L1456">			List&lt;String&gt; tags = Arrays.asList(&quot;seem&quot;, &quot;appear&quot;);</span>
<span class="fc" id="L1457">			CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L1458" title="All 2 branches covered.">			for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc bfc" id="L1459" title="All 2 branches covered.">				for (CoreLabel token : sentence.tokens()) {</span>
<span class="fc bfc" id="L1460" title="All 4 branches covered.">					if (posTags.contains(token.tag()) &amp;&amp; tags.contains(token.lemma())) {</span>
<span class="fc" id="L1461">						Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L1462">						addToScoreMap(scoreMap, &quot;SEMP&quot;, new BigDecimal(1));</span>
<span class="fc" id="L1463">						token.set(getAnnotationClass(), scoreMap);</span>
					}
<span class="fc" id="L1465">				}</span>
<span class="fc" id="L1466">			}</span>
		}
<span class="nc" id="L1468">		catch (Throwable t) {</span>
<span class="nc" id="L1469">			logger.error(t);</span>
<span class="fc" id="L1470">		}</span>
<span class="fc" id="L1471">	}</span>
	

	public void annotate_CONT(Annotation annotation) {
/*
The contractions were tagged by identifying any instance of apostrophe followed by a tagged
word OR any instance of the item n’t.
 */
<span class="fc" id="L1479">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L1480" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc bfc" id="L1481" title="All 2 branches covered.">			for (CoreLabel token : sentence.tokens()) {</span>
<span class="fc bfc" id="L1482" title="All 4 branches covered.">				if (token.lemma().equals(&quot;not&quot;) &amp;&amp; token.originalText().equals(&quot;n\'t&quot;)) {</span>
<span class="fc" id="L1483">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L1484">					addToScoreMap(scoreMap, &quot;CONT&quot;, new BigDecimal(1));</span>
<span class="fc" id="L1485">					token.set(getAnnotationClass(), scoreMap);</span>
				}
<span class="fc" id="L1487">			}</span>
<span class="fc" id="L1488">		}</span>
<span class="fc" id="L1489">	}</span>
	
	
	//TODO
	public void annotate_THATD(Annotation annotation) {
/*
The tag THATD is added when one of the following patterns is found: (1) a public, private or
suasive verb followed by a demonstrative pronoun (DEMP) or a subject form of a personal
pronoun; (2) a public, private or suasive verb is followed by a pronoun (PRP) or a noun (N)
and then by a verb (V) or auxiliary verb; (3) a public, private or suasive verb is followed by
an adjective (JJ or PRED), an adverb (RB), a determiner (DT, QUAN, CD) or a possessive
pronoun (PRP$) and then a noun (N) and then a verb or auxiliary verb, with the possibility of
an intervening adjective (JJ or PRED) between the noun and its preceding word.
 */
<span class="fc" id="L1503">	}</span>
	
	public void annotate_STPR(Annotation annotation) {
<span class="fc" id="L1506">		List&lt;String&gt; posTags = Arrays.asList(&quot;IN&quot;);</span>
<span class="fc" id="L1507">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L1508" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc" id="L1509">			boolean wasPIN = false;</span>
<span class="fc" id="L1510">			CoreLabel pinToken = null;</span>
<span class="fc bfc" id="L1511" title="All 2 branches covered.">			for (CoreLabel token : sentence.tokens()) {</span>
<span class="fc bfc" id="L1512" title="All 4 branches covered.">				if (wasPIN &amp;&amp; isPunctuationMark(token)) {</span>
<span class="fc" id="L1513">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L1514">					addToScoreMap(scoreMap, &quot;STPR&quot;, new BigDecimal(1));</span>
<span class="pc bpc" id="L1515" title="1 of 2 branches missed.">					if (pinToken != null) {</span>
<span class="fc" id="L1516">						pinToken.set(getAnnotationClass(), scoreMap);</span>
					}
					break;
				}
<span class="fc bfc" id="L1520" title="All 2 branches covered.">				if (posTags.contains(token.tag())) {</span>
<span class="fc" id="L1521">					pinToken = token;</span>
<span class="fc" id="L1522">					wasPIN = true;</span>
				}
				else {
<span class="fc" id="L1525">					wasPIN = false;</span>
				}
<span class="fc" id="L1527">			}</span>
<span class="fc" id="L1528">		}</span>
<span class="fc" id="L1529">	}</span>
	

	public void annotate_SPIN(Annotation annotation) {
/*
(e.g. he wants to convincingly prove that…)
Split infinitives are identified every time an infinitive marker to is followed by one or two
adverbs and a verb base form. 
 */
<span class="fc" id="L1538">		TokenSequencePattern pattern= TokenSequencePattern.compile(&quot;[{pos:TO}] [{pos:RB}] [{pos:VB } | {pos:VBD} | {pos:VBG} | {pos:VBN} | {pos:VBP} | {pos:VBZ} ]&quot;);</span>
<span class="fc" id="L1539">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L1540" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc" id="L1541">			List&lt;CoreLabel&gt; tokens = sentence.tokens();</span>

<span class="fc" id="L1543">			TokenSequenceMatcher matcher = pattern.getMatcher(tokens);</span>
<span class="fc bfc" id="L1544" title="All 2 branches covered.">			while (matcher.find()) {</span>
<span class="fc" id="L1545">				List&lt;CoreMap&gt; matchedTokens = matcher.groupNodes();</span>
<span class="fc" id="L1546">				CoreMap token = null;</span>
<span class="fc bfc" id="L1547" title="All 2 branches covered.">				for (CoreMap t : matchedTokens) {</span>
<span class="fc" id="L1548">					token = t;</span>
<span class="fc" id="L1549">				}</span>
<span class="pc bpc" id="L1550" title="1 of 2 branches missed.">				if (token != null) {</span>
<span class="fc" id="L1551">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L1552">					addToScoreMap(scoreMap, &quot;SPIN&quot;, new BigDecimal(1));</span>
<span class="fc" id="L1553">					token.set(getAnnotationClass(), scoreMap);</span>
				}
<span class="fc" id="L1555">			}</span>
<span class="fc" id="L1556">		}</span>
<span class="fc" id="L1557">	}</span>
	

	public void annotate_SPAU(Annotation annotation) {
/*
(e.g. they are objectively shown that…)
Split auxiliaries are identified every time an auxiliary (any modal verb MD, or any form of
DO, or any form of BE, or any form of HAVE) is followed by one or two adverbs and a verb
base form. 
 */
		
<span class="fc" id="L1568">		TokenSequencePattern pattern= TokenSequencePattern.compile(&quot;[{pos:MD} | {lemma:do} | {lemma:have} | {lemma:be}] [{pos:RB}] [{pos:VB } | {pos:VBD} | {pos:VBG} | {pos:VBN} | {pos:VBP} | {pos:VBZ} ]&quot;);</span>
<span class="fc" id="L1569">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L1570" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc" id="L1571">			List&lt;CoreLabel&gt; tokens = sentence.tokens();</span>

<span class="fc" id="L1573">			TokenSequenceMatcher matcher = pattern.getMatcher(tokens);</span>
<span class="fc bfc" id="L1574" title="All 2 branches covered.">			while (matcher.find()) {</span>
<span class="fc" id="L1575">				List&lt;CoreMap&gt; matchedTokens = matcher.groupNodes();</span>
<span class="fc" id="L1576">				CoreMap token = null;</span>
<span class="fc bfc" id="L1577" title="All 2 branches covered.">				for (CoreMap t : matchedTokens) {</span>
<span class="fc" id="L1578">					token = t;</span>
<span class="fc" id="L1579">				}</span>
<span class="pc bpc" id="L1580" title="1 of 2 branches missed.">				if (token != null) {</span>
<span class="fc" id="L1581">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L1582">					addToScoreMap(scoreMap, &quot;SPAU&quot;, new BigDecimal(1));</span>
<span class="fc" id="L1583">					token.set(getAnnotationClass(), scoreMap);</span>
				}
<span class="fc" id="L1585">			}</span>
<span class="fc" id="L1586">		}</span>
<span class="fc" id="L1587">	}</span>
	

	public void annotate_PHC(Annotation annotation) {
<span class="fc" id="L1591">		List&lt;String&gt; posTags = Arrays.asList(&quot;NN&quot;, &quot;NNS&quot;, &quot;NNP&quot;, &quot;NNPS&quot;, &quot;JJ&quot;, &quot;JJR&quot;, &quot;JJS&quot;, &quot;RB&quot;, &quot;RBR&quot;, &quot;RBS&quot;, &quot;VB&quot;, &quot;VBD&quot;, &quot;VBG&quot;, &quot;VBN&quot;, &quot;VBP&quot;, &quot;VBZ&quot;);</span>
<span class="fc" id="L1592">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L1593" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc bfc" id="L1594" title="All 2 branches covered.">			for (int i=0;i&lt;sentence.tokens().size();i++) {</span>
<span class="fc bfc" id="L1595" title="All 4 branches covered.">				if (i&gt;0 &amp;&amp; i&lt;sentence.tokens().size()-1) {</span>
<span class="fc bfc" id="L1596" title="All 6 branches covered.">					if (sentence.tokens().get(i).lemma().equals(&quot;and&quot;) &amp;&amp; posTags.contains(sentence.tokens().get(i-1).tag()) &amp;&amp; sentence.tokens().get(i-1).tag().equals(sentence.tokens().get(i+1).tag())) {</span>
<span class="fc" id="L1597">						Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(sentence.tokens().get(i));</span>
<span class="fc" id="L1598">						addToScoreMap(scoreMap, &quot;PHC&quot;, new BigDecimal(1));</span>
<span class="fc" id="L1599">						sentence.tokens().get(i).set(getAnnotationClass(), scoreMap);</span>
					}					
				}
			}
<span class="fc" id="L1603">		}</span>
<span class="fc" id="L1604">	}</span>
	

	public void annotate_ANDC(Annotation annotation) {
/*
This tag is assigned to the word and when it is found in one of the following patterns: (1)
preceded by a comma and followed by it, so, then, you, there + BE, or a demonstrative 
pronoun (DEMP) or the subject forms of a personal pronouns; (2) preceded by any
punctuation; (3) followed by a WH pronoun or any WH word, an adverbial subordinator
(CAUS, CONC, COND, OSUB) or a discourse particle (DPAR) or a conjunct (CONJ). 
 */
<span class="fc" id="L1615">	}</span>
	
	public void annotate_SYNE(Annotation annotation) {
<span class="fc" id="L1618">		List&lt;String&gt; posTags = Arrays.asList(&quot;NN&quot;, &quot;NNS&quot;, &quot;NNP&quot;, &quot;NNPS&quot;);</span>
<span class="fc" id="L1619">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L1620" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc" id="L1621">			boolean wasNot = false;</span>
<span class="fc" id="L1622">			boolean wasJJ = false;</span>
<span class="fc bfc" id="L1623" title="All 2 branches covered.">			for (CoreLabel token : sentence.tokens()) {</span>
<span class="fc bfc" id="L1624" title="All 6 branches covered.">				if (wasNot &amp;&amp; wasJJ &amp;&amp; posTags.contains(token.tag())) {</span>
<span class="fc" id="L1625">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L1626">					addToScoreMap(scoreMap, &quot;SYNE&quot;, new BigDecimal(1));</span>
<span class="fc" id="L1627">					token.set(getAnnotationClass(), scoreMap);</span>
<span class="fc" id="L1628">				}</span>
<span class="fc bfc" id="L1629" title="All 4 branches covered.">				else if (wasNot &amp;&amp; token.tag().equals(&quot;JJ&quot;)) {</span>
<span class="fc" id="L1630">					wasJJ = true;</span>
				}
<span class="pc bpc" id="L1632" title="1 of 6 branches missed.">				else if (token.lemma().equals(&quot;no&quot;) || token.lemma().equals(&quot;not&quot;) || token.lemma().equals(&quot;neither&quot;)) {</span>
<span class="fc" id="L1633">					wasNot = true;</span>
				}
				else {
<span class="fc" id="L1636">					wasNot = false;</span>
<span class="fc" id="L1637">					wasJJ = false;</span>
				}
<span class="fc" id="L1639">			}</span>
<span class="fc" id="L1640">		}</span>
<span class="fc" id="L1641">	}</span>
	
	public void annotate_XX0(Annotation annotation) {
<span class="fc" id="L1644">		CoreDocument document = new CoreDocument(annotation);</span>
<span class="fc bfc" id="L1645" title="All 2 branches covered.">		for (CoreSentence sentence : document.sentences()) {</span>
<span class="fc bfc" id="L1646" title="All 2 branches covered.">			for (CoreLabel token : sentence.tokens()) {</span>
<span class="fc bfc" id="L1647" title="All 2 branches covered.">				if (token.lemma().equals(&quot;not&quot;)) {</span>
<span class="fc" id="L1648">					Map&lt;String, BigDecimal&gt; scoreMap = getBiberAnnotation(token);</span>
<span class="fc" id="L1649">					addToScoreMap(scoreMap, &quot;XX0&quot;, new BigDecimal(1));</span>
<span class="fc" id="L1650">					token.set(getAnnotationClass(), scoreMap);</span>
				}
<span class="fc" id="L1652">			}</span>
<span class="fc" id="L1653">		}</span>
<span class="fc" id="L1654">	}</span>

	
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>